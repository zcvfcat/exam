# (구) 정보처리기사

## 소프트웨어 설계

### 1장 요구 사항 확인

#### 001 소프트웨어 생명 주기 (Software Life Cycle)

- 소프트웨어 개발 방법론의 바탕이 되는 것
- 소프트웨어를 개발하기 위해 정의하고 운용, 유지보수 등의 돠정을 각 단계별로 나눈 것
- 소프트웨어 개발 단게와 각 단계별 주요활동, 그리고 활동의 결과에 대한 산출물로 표현함
- 소프트웨어 생명 주기 모형에는 폭포수 모형, 프로토타입 모형, 나선형 모형, 애자일 모형

```t
소프트웨어 생명 주기는 소프트웨어를 개발하기 위해 필요한 단계들을 계획, 설계, 구현, 테스트와 같이 나눈 것입니다. 이 모델은 소프트웨어 개발 방법론의 기반이 되는 개념으로, 소프트웨어가 완성되기까지의 과정을 분류하고 각 과정에서 수행되는 주요 작업과 산출물을 설명합니다.

소프트웨어 생명 주기 모형에는 다양한 종류가 있습니다. 그 중 대표적인 것은 폭포수 모형, 프로토타입 모형, 나선형 모형, 애자일 모형 등이 있습니다.

1. 폭포수 모형

폭포수 모형은 소프트웨어 개발 과정을 계획, 요구사항 확인, 설계, 구현, 테스트, 유지보수 등 여러 단계로 나누어 진행하는 선형 모델입니다. 즉, 각 단계가 순서대로 진행되며, 나중에 이전 단계의 결과물이 바탕이 되어 다음 단계를 수행하게 됩니다.

2. 프로토타입 모형

프로토타입 모형은 요구사항 수집과 설계, 만들기 및 평가로 나눠져 있으며, 빠른 시간 내에 사용자의 요구 사항을 파악할 수 있습니다. 이 모델에서는 초기 개발된 프로토타입을 바탕으로 반복적인 수정과 보완 작업을 거쳐 최종 소프트웨어를 구현합니다.

3. 나선형 모형

나선형 모형은 계획, 위험 분석, 공학적 개발, 고객 평가라는 네 단계로 구성됩니다. 이 모델에서는 위험 분석을 통해 위험 부분을 미리 파악하고 대처할 수 있는 방식으로 개발이 진행됩니다.

4. 애자일 모형

애자일 모형은 개발 방법론 중 하나로서, 기능별 작게 쪼개어 짧은 주기(iteration)로 나누어 지속적으로 배포하는 방식입니다. 이 모델에서는 개발에 필요한 적응력과 유연성을 확보할 수 있으며, 프로젝트 완료까지 변화하는 상황에 대비하는 것이 가능합니다.
```

##### 폭포수 모형 (Waterfall Model)

- 한 단계가 완전히 끝나야만 다음 단계로 넘어가는 개발 방법론
- 이전 단계로 돌아갈 수 없다는 전제하에 각 단계를 확실히 매듭짓고 그 결과를 철저하게 검토하여 승인 과정을 거친 후에 다음 단계를 진행하는 개발 방법론
- 고전적 생명 주기 모형
- 하향식 접근방법을 제공
- 낮은 기술적 위험과 유사 프로젝트 경험이 있는 경우 요구사항의 명확한 정의가 가능
- 계획 -> 요구사항 분석 -> 설계 -> 구현 -> 테스트 -> 유지보수

```t
폭포수 모형(Waterfall Model)은 소프트웨어 개발 방법론 중 하나로, 순차적으로 진행되는 단계를 밟고 마침내 개발을 끝마치는 선형적인 생명 주기 모형입니다.

계획 -> 요구사항 분석 -> 설계 -> 구현 -> 테스트 -> 유지보수의 6단계로 구성되어 있으며, 각 단계에서는 이전 단계의 결과물을 바탕으로 다음 단계를 진행합니다. 따라서 한 단계가 완전히 끝나야만 다음 단계로 넘어갈 수 있습니다.

또한, 폭포수 모형에서는 각 단계에서 만들어진 산출물에 대한 검토가 필수적으로 이루어져야 합니다. 이전 단계로 돌아갈 수 없다는 전제하에 각 단계를 확실히 매듭짓고 그 결과를 철저하게 검토하여 승인 과정을 거친 후에 다음 단계를 진행하는 것이 특징입니다.

폭포수 모형은 고전적인 생명 주기 모형이며, 하향식 접근방법을 제공합니다. 또한, 낮은 기술적 위험과 유사 프로젝트 경험이 있는 경우 요구사항의 명확한 정의가 가능해서 개발자가 따라하기 쉽습니다. 하지만, 프로젝트 초기에 모든 요구사항이 분석되어야 하기 때문에 변경사항 발생 시 추가 비용이 발생하며, 관리가 잘 되지 않으면 일정 지연 및 비용 증가 요인이 될 수 있습니다.
```

##### 프로토타입 모형(Prototype Model, 원형 모형)

- 사용자의 요구사항을 정확히 파악하기 위해 실제 개발될 소프트웨어에 대한 견본(시제)품(Prototype)을 만들어 최종 결과물을 예측하는 모형
- 시스템은 사용자와 시스템 사이의 인터페이스에 중점을 두어 개발함

```t
프로토타입 모형(Prototype Model, 원형 모형)은 사용자의 요구사항을 정확히 파악하기 위해 실제 개발될 소프트웨어에 대한 견본(시제)품(Prototype)을 만들어 최종 결과물을 예측하는 모형입니다. 이 모형은 초기에 생각나는 아이디어를 빠르게 구현하여 실제 사용자와 상호작용하면서 개발하는 방식으로 진행됩니다.

프로토타입 모형에서는 소프트웨어 개발 초기에 사용자가 원하는 기능과 인터페이스를 파악하고, 이를 바탕으로 견본품을 만듭니다. 만들어진 프로토타입을 사용자들에게 제공하고, 사용자들의 피드백을 수집하여 소프트웨어를 보완 및 수정합니다. 이런 과정을 거치면서 최종 결과물에 대한 예상을 보다 정확하게 할 수 있으며, 사용자의 요구사항을 충족시키기 위한 소프트웨어를 개발할 수 있습니다.

프로토타입 모형에서는 시스템의 인터페이스에 중점을 두어 개발합니다. 따라서, UX/UI에 관심이 많은 분야에서 많이 사용되며, 이를 통해 최종 결과물의 사용자 경험(UX)을 보다 개선할 수 있습니다. 또한, 소프트웨어 개발 초기에 문제점을 발견하여 빠르게 해결할 수 있는 장점이 있습니다. 하지만, 추가적인 개발 비용과 시간이 소요될 수 있다는 단점도 존재합니다.
```

##### 나선형 모형(Spiral Model, 점진적 모형)

- 폭포수 모형과 프로토타입 모형의 장점에 위험 분석 기능을 추가한 모형
- 나선을 따라 돌듯이 여러 번의 소프트웨어 개발 과정을 거쳐 점진적으로 완벽한 최종 소프트웨어를 개발하는 것, `점진적 모형`이라고도 함
- 위험을 관리하고 최소화하는 것을 목적으로 함
- 대규모 시스템 개발에 적합
- 계획 및 정의 -> 위험 분석 -> 개발 -> 고객 평가

```t
나선형 모형(Spiral Model, 점진적 모형)은 폭포수 모형과 프로토타입 모형의 장점에 위험 분석 기능을 추가한 소프트웨어 개발 모형입니다. 나선을 따라 돌듯이 여러 번의 소프트웨어 개발 과정을 거쳐 점진적으로 완벽한 최종 소프트웨어를 개발하는 것이 특징입니다.

나선형 모형은 위험을 관리하고 최소화하는 것을 목적으로 합니다. 이를 위해 소프트웨어 개발 초기부터 위험 분석을 수행하며, 프로젝트가 진행됨에 따라 위험을 줄이기 위한 계획을 수립하고 실행합니다. 이렇게 위험을 줄이는 것이 전체 프로젝트의 진행상황을 획기적으로 개선시키며, 최종 결과물이 보다 안정적으로 완성될 수 있도록 합니다.

나선형 모형은 대규모 시스템 개발에 적합합니다. 단계별로 필요한 요구사항을 파악하며, 이를 바탕으로 소프트웨어 개발을 진행합니다. 계획 및 정의, 위험 분석, 개발, 고객 평가 단계를 거칩니다. 이 과정에서 위험을 최대한 줄이고, 최종 결과물의 품질을 높일 수 있습니다. 필요에 따라 기능을 추가하거나 수정하는 것이 가능하여 요구사항 변경에도 유연하게 대처할 수 있는 장점도 있습니다.
```

##### 애자일 모형 (Agile Model)

- 애자일은 '민첩한', '기민한' 이라는 의미
- 고객의 요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하면서 개발과정을 진행함
- 애자일 모형은 어느 특정 개발 방법론이 아니라 좋은 것을 빠르고 낭비 없게 만들기 위해 고객과의 소통에 초점을 맞춘 방법론을 통칭함
- 애자일 모형은 스프린트(Spring) 또는 이터레이션(Iteration) 이라고 불리는 짧은 개발 주기를 반복하며, 반복되는 주기마다 만들어지는 결과물에 대한 고갹의 평가와 요구를 적극 수용함
- 소규모 프로젝트, 고도로 숙련된 개발자, 급변하는 요구사항에 적합함
- 애자일 모형을 기반으로 하는 소프트웨어 개발 모형에는 스크럼(Scrum), XP(eXtreme Programming), 칸반(Kanban), Lean, 크리스탈(Crystal), ASD(Adaptive Software Development), FDD(Feature Driven Development), DSDM(Dynamic System Development Method), DAD(Disciplined Agile Delivery) 등이 있음

```t
애자일 모형 (Agile Model)은 '민첩한', '기민한' 이라는 의미로, 고객의 요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하면서 개발과정을 진행하는 소프트웨어 개발 모형입니다. 애자일 모형은 어느 특정 개발 방법론이 아니라 좋은 것을 빠르고 낭비 없게 만들기 위해 고객과의 소통에 초점을 맞춘 방법론을 통칭합니다.

애자일 모형은 스프린트(Spring) 또는 이터레이션(Iteration) 이라고 불리는 짧은 개발 주기를 반복하며, 반복되는 주기마다 만들어지는 결과물에 대한 고갹의 평가와 요구를 적극 수용합니다. 이를 통해 고객의 요구에 부합하는 소프트웨어를 보다 빠르게 개발할 수 있습니다. 또한, 개발자와 고객 간 소통이 원활하게 이루어지며, 비즈니스 환경의 변화나 요구사항 변경에 유연하게 대처할 수 있는 장점이 있습니다.

애자일 모형은 소규모 프로젝트, 고도로 숙련된 개발자, 급변하는 요구사항에 적합합니다. 또한 애자일 모형을 기반으로 하는 소프트웨어 개발 모형에는 스크럼(Scrum), XP(eXtreme Programming), 칸반(Kanban), Lean, 크리스탈(Crystal), ASD(Adaptive Software Development), FDD(Feature Driven Development), DSDM(Dynamic System Development Method), DAD(Disciplined Agile Delivery) 등이 있습니다.
```

#### 002 스크럼(Scrum) 기법

- 팀의 중요성을 강조, 팀이 중심이 되어 개발의 효율성을 높인다는 의미가 내포된 용어
- 스크럼은 팀원 스스로가 스크럼 팀을 구성(self-organizing)해야 하며, 개발 작업에 관한 모든 것을 스스로 해결(cross-functional)할 수 있어야 한다
- 스크럼 팀은 제품 책임자, 스크럼 마스터, 개발팀으로 구성
  - 제품 책임자(PO; Product Owner)
  - 스크럼 마스터(SM; Scrum Master)
  - 개발팀(DT; Development Team)

```t
스크럼(Scrum)은 팀의 중요성을 강조하며, 팀이 중심이 되어 개발의 효율성을 높인다는 의미가 내포된 용어로서, 소프트웨어 개발 프로젝트를 위한 점진적이고 반복적인 방법론입니다.

스크럼은 팀원 스스로가 스크럼 팀을 구성(self-organizing)해야 하며, 개발 작업에 관한 모든 것을 스스로 해결(cross-functional)할 수 있어야 합니다. 이를 통해 팀 구성원들이 자율적으로 일을 진행하며, 업무 수행에 높은 책임감과 참여도를 가질 수 있습니다.

스크럼 팀은 제품 책임자(Product Owner; PO), 스크럼 마스터(Scrum Master; SM), 개발팀(Development Team; DT)으로 구성됩니다. 제품 책임자는 제품에 대한 최종 책임을 지며, 제품 백로그(Product Backlog)를 관리합니다. 스크럼 마스터는 스크럼 프로세스를 지원하며, 스크럼 팀이 프로세스를 올바르게 따르도록 지도합니다. 개발팀은 개발 작업을 수행하며, 제품이나 서비스를 만드는 데 필요한 모든 스킬과 역량을 가지고 있습니다.

스크럼은 매일 스크럼 미팅(Daily Scrum Meeting) 등의 일정한 이벤트를 통해 스크럼 팀의 협업과 의사소통을 강화하고, 짧은 시간 내에 반복적으로 개발 작업을 완료함으로써 고객의 요구사항에 따르는 프로젝트 성공을 목표로 합니다.
```

##### 스크럼 개발 프로세스

- 제품 백로그(Product Backlog)
  - 요구사항(User Story)을 우선순위에 따라 나열한 목록
- 스프린트 게획 회의(Sprint Planning Meeting)
- 스프린트(Sprint)
- 일일 스크럼 회의(Daliy Scrum Meeting)
  - 남은 작업 시간은 소멸 차트 (Burn-down CHart)에 표시함
- 스프린트 검토 회의(Sprint Review)
- 스프린트 회고(Sprint Retrospective)

```t
스크럼(Scrum) 개발 프로세스는 크게 6단계로 구성됩니다.

1. 제품 백로그(Product Backlog)
- 요구사항(User Story)을 우선순위에 따라 나열한 목록입니다.
- 이 단계에서는 고객의 요구사항이나 제품 비전 등을 바탕으로 제품의 기능을 명세하고, 우선순위를 정하는 작업을 수행합니다.

2. 스프린트 게획 회의(Sprint Planning Meeting)
- 제품 백로그에 있는 요구사항들 중에서 일정 기간 내에 개발할 항목들을 선별하고, 그것을 완료하기 위해 수행할 작업 계획을 수립합니다.
- 이 단계에서는 개발 팀원들은 각자 자신의 역할과 할 일에 대해 논의합니다.

3. 스프린트(Sprint)
- 일정된 시간 동안 제품에 새로운 기능을 추가하거나, 버그 수정 작업 등을 수행합니다.
- 스프린트는 보통 1주일 이상 4주 이하의 기간으로 설정됩니다.

4. 일일 스크럼 회의(Daily Scrum Meeting)
- 하루 한 번, 짧은 시간동안(보통 15분 이내) 각 팀원이 자신의 진행 상황과 다음에 수행할 일을 공유합니다.
- 남은 작업 시간은 소멸 차트(Burn-down Chart)에 표시합니다.

5. 스프린트 검토 회의(Sprint Review)
- 스프린트가 끝나면, 완료된 작업물을 고객 및 이해관계자들에게 제시하고, 피드백을 받습니다.
- 만약 개선할 사항이 발견되면, 새로운 요구사항으로 추가할 수 있습니다.

6. 스프린트 회고(Sprint Retrospective)
- 스프린트를 진행하면서 문제점이나 개선할 점 등을 돌아보고, 다음 스프린트에서 개선할 계획을 수립하는 단계입니다.
- 이 단계는 개발 프로세스를 지속적으로 개선해나가는 데 있어 매우 중요한 단계입니다.
```

#### 003 XP(eXtreme Programming) 기법

- XP는 수시로 발생하는 고객의 요구 사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복을 극대화하여 개발 생산성을 향상시키는 방법
- XP는 짧고 반복적인 개발 주기, 단순한 설계, 고객의 적극적인 참여를 통해 소프트웨어를 빠르게 개발하는 것을 목적으로 함
- 릴리즈의 시간을 짧게 반복하면서 고객의 요구사항 반영에 대한 가시성을 높임
- 비교적 소규모 인원의 개발 프로젝트에 효과적
- XP의 5개자 핵심 가치: 의사소통(Communication), 단순성(Simplicity), 용기(Courage), 존중(Respect), 피드백(Feedback)

```t
XP(eXtreme Programming)는 고객의 요구사항을 유연하게 대처하면서 개발 생산성을 향상시키기 위해 고객의 적극 참여와 개발과정 반복을 극대화하여 사용하는 개발 방법론입니다.

XP는 짧은 개발 주기를 설정하고, 단순한 설계, 고객의 적극적인 참여를 통해 빠르게 소프트웨어를 개발하는 것을 목적으로 합니다. 이렇게 짧은 개발 주기를 반복함으로써, 릴리즈 시간을 줄이고 고객의 요구사항을 빠르게 반영할 수 있습니다.

XP는 비교적 소규모 인원의 개발 프로젝트에 효과적으로 사용될 수 있으며, 소수의 개발자들로 구성된 팀에서도 잘 작동합니다. 또한, XP는 기본적으로 다른 Agile 방법론과 결합해서 사용할 수도 있습니다.

XP의 5가지 핵심 가치는 의사소통(Communication), 단순성(Simplicity), 용기(Courage), 존중(Respect), 피드백(Feedback)입니다. 이 가치들을 중심으로 개발 프로세스를 진행하면서 고객의 요구사항을 빠르게 반영하고, 품질 높은 소프트웨어를 개발할 수 있습니다. IEnumerable동작하는 예제 코드로 설명해주면 좋겠어요.
```

##### XP 개발 프로세스

- 사용자 스토리(User Story)
- 릴리즈 계획 수립(Release Planning)
- 스파이크(Spike)
  - 요구 사항의 신뢰성을 높이고 기술 문제에 대한 위험을 감소시키기 위해 별도로 만드는 간단한 프로그램
  - 처리할 문제 외의 다른 조건은 모두 무시하고 작성함
- 이터레이션(Iteration)
- 승인 검사(Acceptance Test, 인수 테스트)
- 소규모 릴리즈(Small Release)

```t
XP(eXtreme Programming) 개발 프로세스는 아래와 같은 과정으로 진행됩니다.

1. 사용자 스토리(User Story)

- 사용자의 관점에서 요구되는 기능을 설명하는 간단한 형태의 문장(스토리)로 작성합니다.
- 스토리는 사용자 눈높이에서 작성되며, 사용자가 원하는 것을 정확하게 전달해야 합니다.
- 이 스토리들은 우선순위를 결정하여 필요에 따라 시간을 조정할 수 있습니다.

2. 릴리즈 계획 수립(Release Planning)

- 모든 스토리를 포함하는 릴리즈 계획(공개일정)을 만듭니다.
- 릴리즈 일자와 릴리즈에 들어갈 스토리 등이 명시됩니다.

3. 스파이크(Spike)

- 스파이크(Spike)는 요구 사항의 신뢰성을 높이고 기술 문제에 대한 위험을 감소시키기 위해 별도로 만드는 간단한 프로그램입니다.
- 처리할 문제 외의 다른 조건은 모두 무시하고 작성합니다.

4. 이터레이션(Iteration)

- 사용자 스토리 중 하나 이상을 모은 작업 단위로 이터레이션(Iteration)을 수행합니다.
- 개발, 테스트 및 피드백을 포함한 수행 계획을 수립하고, 1주일에서 2주 간격으로 진행됩니다.

5. 승인 검사(Acceptance Test, 인수 테스트)

- 이터레이션의 결과물에 대한 인수 테스트를 수행합니다.
- 릴리즈할 만한 기능이 완성되었다면, 고객에게 승인을 받습니다.

6. 소규모 릴리즈(Small Release)

- 몇 개의 스토리를 끊어내어 소규모 릴리즈를 진행합니다.
- 릴리즈 후 고객의 피드백을 반영하여, 다음 이터레이션에 적용합니다.

이러한 방식으로 XP 개발 프로세스는 고객의 요구사항 변화에 유연하게 대처하면서 효율적인 소프트웨어 개발을 가능하게 합니다.
```

##### XP의 주요 실천 방법(Practice)

- Pair Programming(짝 프로그래밍)
- Test-Driven Development(테스트 주도 개발)
- Whole Team(전체 팀)
- Continuous Integration(계속적인 통합)
- Design Improvement(디자인 개선) 또는 Refactoring(리팩토링)
- Small Releases(소규모 릴리즈)

```t
XP(eXtreme Programming)의 주요 실천 방법(Practice)은 아래와 같습니다.

1. Pair Programming(짝 프로그래밍)

- 두 명의 개발자가 하나의 컴퓨터에서 동시 작업하는 개발 방식입니다.
- 코드 리뷰 및 빠른 피드백과 지속적인 지식 공유 등의 장점이 있습니다.

2. Test-Driven Development(테스트 주도 개발)

- 개발하기 전에 테스트를 먼저 작성하고, 해당 테스트를 통과할 수 있는 코드를 작성하는 방법입니다.
- 코드의 오류를 예방하고, 유지보수 시간을 단축하는 장점이 있습니다.

3. Whole Team(전체 팀)

- XP에서는 전체 팀원이 소프트웨어 제작에 참여합니다.
- 개발자, 테스터, 디자이너 등의 역할 구분 없이 모두가 함께 일하는 방식입니다.

4. Continuous Integration(계속적인 통합)

- 개발 초기 단계부터 지속적으로 통합을 수행하는 방식입니다.
- 코드 변경사항이 발생할 때마다 적극적으로 통합하여, 개발 중 발생 가능한 문제점을 최대한 조기에 해결할 수 있습니다.

5. Design Improvement(디자인 개선) 또는 Refactoring(리팩토링)

- 지속적인 설계 개선을 통해 소프트웨어 구조와 코드의 가독성, 유지보수성 등을 향상시키는 방법입니다.
- 리팩토링은 기존의 코드를 수정하거나 재구성하여, 기능에 변화를 주지 않으면서 코드를 개선하는 작업입니다.

6. Small Releases(소규모 릴리즈)

- 짧은 시간 간격으로 소규모의 프로덕션 코드를 릴리즈하는 방식입니다.
- 빠른 피드백 및 문제 발생 시 적절한 대응이 가능하며, 고객 요구사항 변화에 빠르게 대처할 수 있습니다.

이러한 XP의 실천 방법들을 조합하여, 빠르고 정확하게 고객의 요구 사항을 반영하며 높은 품질의 소프트웨어를 개발할 수 있습니다.
```

#### 004 현행 시스템 파악

- 새로 개발하려는 시스템의 개발 범위를 명확히 설정하기 위해 현행 시스템의 구성과 제공 기능, 시스템 간의 전달 정보, 사용되는 기술 요소, 소프트웨어, 하드웨어, 그리고 네트워크의 구성 등을 파악

```t
현행 시스템 파악은 새로운 소프트웨어 시스템을 개발하기 전에 기존 시스템의 구성과 제공하는 기능, 시스템 간의 데이터 전달 정보, 사용되는 기술 요소, 소프트웨어와 하드웨어 등 프로그램의 전반적인 구성요소를 파악하는 것입니다.

시스템 파악은 다음과 같은 이유로 중요합니다.

1. 기능 분석: 시스템의 구성요소, 데이터 흐름 및 기능 등을 파악하여 기능을 분석함으로써 새로운 시스템의 범위를 명확히 설정할 수 있습니다.

2. 문제 파악: 기존 시스템에서 발생한 문제점을 파악하고, 이를 개선하여 새로운 시스템에서 반영할 수 있습니다.

3. 기술 선택: 기존 시스템에서 사용된 기술 요소들을 파악해 새로운 시스템에서 해당 기술을 지속적으로 활용할 것인지, 바꿀 것인지를 결정할 수 있습니다.

4. 호환성 검증: 새로운 시스템이 기존 시스템과 호환되도록 구성요소를 파악함으로써, 기존 시스템의 데이터 이관 및 연계를 원활하게 할 수 있습니다.

5. 비용 산정: 기존 시스템에서 사용된 하드웨어, 소프트웨어, 네트워크 등에 대한 정보를 파악해 비용 측면에서 어떤 문제가 생길 수 있는지 확인할 수 있습니다.

따라서 현행 시스템 파악은 새로운 시스템 개발에서의 중요한 단계이며, 충분한 분석과 조사가 필요합니다.
```

##### 현행 시스템 파악 절차

- 1단계 : 시스템 구성 파악 | 시스템 기능 파악 | 시스템 인터페이스 파악
- 2단계 : 아키텍처 구성 파악 | 소프트웨어 구성 파악
- 3단계 : 하드웨어 구성 파악 | 네트워크 구성 파악

##### 시스템 구성 파악

- 현행 시스템의 구성은 조직의 주요 업무를 담당하는 기간 업무와 이를 지원하는 지원 업무로 구분하여 기술함
- 조직 내에 있는 모든 정보시스템의 현황을 파악 할 수 있도록 각 업무에 속하는 단위 업무 정보시스템들의 명칭, 주요 기능들을 명시함

##### 시스템 기능 파악

- 현행 시스템의 기능은 단위 업무 시스템이 현재 제공하는 기능들을 주요 기능과 하부 기능, 세부 기능으로 구분하여 계층형으로 표시함

##### 시스템 인터페이스 파악

- 현행 시스템의 인터페이스에는 단위 업무 시스템 간에 주고 받는 데이터의 종류, 형식, 프로토콜, 연계 유형, 주기 등을 명시함

##### 아키텍처 구성 파악

- 현행 시스템의 아키텍처 구성은 기간 업무 수행에 어떠한 기술 요소들이 사용되는지 최상위 수준에서 계층별로 표현한 아키텍처 구성도로 작성함

##### 소프트웨어 구성 파악

- 소프트웨어 구성에는 단위 업무 시스템 별로 업무 처리를 위해 설치되어 있는 소프트웨어들의 제품명, 용도, 라이선스 적용 방식, 라이선스 수 등을 명시함

##### 하드웨어 구성 파악

- 하드 웨어 구성에는 단위 업무 시스템들이 운용되는 서버의 주요 사양과 수량, 그리고 이중화의 적용 여부를 명시함

##### 네트워크 구성 파악

- 네트워크 구성은 업무 시스템들의 네트워크 구성을 파악할 수 있도록 서버의 위치, 서버 간의 네트워크 연결 방식을 네트워크 구성도로 작성함

#### 005 개발 기술 환경 파악

개발 기술 환경: 개발하고자 하는 소프트웨어와 관련된 운영체제(OS), 데이터베이스 관리 시스템(DBMS), 미들웨어(Middle Ware) 등을 선정할 때 고려해야 할 사항을 기술하고, 오픈 소스 사용 시 주의해야 할 내용을 제시.
운영체제(OS)
데이터베이스 관리 시스템(DBMS)
웹 애플리케이션 서버(WAS)
오픈 소스 사용에 따른 고려사항
라이선스의 종류, 사용자 수, 기술의 지속 가능성 등을 고려해야 함.

#### 006 요구사항 정의

- 요구사항: 소프트웨어가 어떤 문제를 해결하기 위해 제공하는 서비스에 대한 설명과 정상적으로 운영되는데 필요한 제약조건 등을 나타냄.

#### 요구사항 유형

- 일반적으로 기술하는 내용에 따라 기능 요구사항과 비기능 요구사항으로 구분하며,

- 기술 관점과 대상의 범위에 따라 시스템 요구사항과 사용자 요구사항으로 나눔.

- 기능 요구사항(Functional requirements)
  - 시스템이 무엇을 하는지, 어떤 기능을 하는지에 대한 사항
- 비기능 요구사항(Non-functional requirements)

- 시스템의 장비 구성 요구사항
  - 성능 요구사항
  - 인터페이스 요구사항
  - 데이터 요구사항
  - 테스트 요구사항
  - 보안 요구사항
  - 품질 요구사항
  - 제약사항
  - 프로젝트 관리 요구사항
  - 프로젝트 지원 요구사항
- 시스템 요구사항(System requirements)
  - 사용자 관점에서 본 시스템이 제공해야 할 요구사항
- 사용자 요구사항(User requirements)

  - 개발자 관점에서 본 시스템 전체가 사용자와 다른 시스템에 제공해야 할 요구사항

- 요구사항 개발 프로세스
  - 개발 대상에 대한 요구사항을 체계적으로 도출하고 이를 분석한 후 분석 결과를 명세서(Specification Document)에 정리한 다음 마지막으로 이를 확인 및 검증하는 일련의 구조화된 활동
  - 요구사항 개발 프로세스가 진행되기 전에 개발 프로세스가 비즈니스 목적에 부합되는지, 예산은 적정한지 등에 대한 정보를 수집, 평가한 보고서를 토대로 타당성 조사(Feasibility Study)가 선행되어야 함.
  - 요구사항 개발은 요구공학(Requirement Engineering)의 한 요소
  - 도출(Elicitation) -> 분석(Analysis) -> 명세(Specification) -> 확인(Validation)
- 요구사항 도출(Requirement Elicitation, 요구사항 수집)
  - 시스템, 사용자, 그리고 시스템 개발에 관련된 사람들이 서로 의견을 교환하여 요구사항이 어디에 있는지, 어떻게 수집할 것인지를 식별하고 이해하는 과정
- 요구사항 분석(Requirement Analysis)
  - 개발 대상에 대한 사용자의 요구사항 중 명확하지 않거나 모호하여 이해되지 않는 부분을 발견하고 이를 걸러내기 위한 과정
- 요구사항 명세(Requirement Specification)
  - 요구사항을 체계적으로 분석한 후 승인될 수 있도록 문서화하는 것.
  - 시스템의 모든 동작뿐만 아니라 성능, 보안, 사용성과 같은 품질도 기술되어야 함.
- 요구사항 확인(Requirement Validation, 요구사항 검증)
  - 개발 자원을 요구사항에 할당하기 전에 요구사항 명세서가 정확하고 완전하게 작성되었는지를 검토하는 활동

### 007 요구사항 분석 기법

- 요구사항 분석 기법: 개발 대상에 대한 사용자의 요구사항 중 명확하지 않거나 모호한 부분을 걸러내기 위한 방법.
- 요구사항 분석 기법에는 요구사항 분류, 개념 모델링, 요구사항 할당, 요구사항 협상, 정형 분석 등

#### 요구사항 분류(Requirement Classification)

#### 개념 모델링(Conceptual Modeling)

- 개념 모델의 종류에는 유스케이스 다이어그램(Use Case Diagram), 데이터 흐름 모델(Data Flow Model), 상태 모델(State Model), 목표기반 모델(Goal-Based Model), 사용자 인터랙션(User Interactions), 객체 모델(Object Model), 데이터 모델(Data Model) 등.
- 모델링 표기는 주로 UML(Unified Modeling Language)을 사용.

#### 요구사항 할당(Requirement Allocation)

#### 요구사항 협상(Requirement Negotiation)

#### 정형 분석(Formal Analysis)

- 정형 분석은 구문(Syntax)과 의미(Semantics)를 갖는 정형화된 언어를 이용해 요구사항을 수학적 기호로 표현한 후 이를 분석하는 과정
- 정형 분석은 요구사항 분석의 마지막 단계에서 이루어짐.
- 정형 명세(Formal Specification): 정형화된 언어를 이용해 수학적 기호로 기술하는 것

### 008 요구사항 확인 기법

- 요구사항 확인 기법: 요구사항 개발 과정을 거쳐 문서화된 요구사항 관련 내용을 확인하고 검증하는 방법.
- 요구사항 확인 기법에는 요구사항 검토(Requirement Reviews), 프로토타이핑(Prototyping), 모델 검증(Model Verification), 인수 테스트(Acceptance Tests) 등.

#### 요구사항 검토(Requirement Reviews)

- 문서화된 요구사항을 훑어보면서 확인하는 것으로 가장 일반적인 요구사항 검증 방법
- 검토는 시스템 정의서(System Definition Document), 시스템 사양서(System Specification), 소프트웨어 요구사항 명세서(SRS; Software Requirements Specification Document) 등을 완성한 시점에 이루어짐.

#### 프로토타이핑(Prototyping)

- 초기 도출된 요구사항을 토대로 프로토타입(Prototype)을 만든 후 대상 시스템의 개발이 진행되는 동안 도출되는 요구사항을 반영하면서 지속적으로 프로토타입을 재작성하는 과정

#### 모델 검증(Model Verification)

- 요구사항 분석 단계에서 개발된 모델이 요구사항을 충족시키는지 검증하는 것
- 객체 모델의 경우 객체들 사이에 존재하는 의사소통 경로(Communication Path)를 검증(Verify)하기 위하여 정적 분석(Static Analysis)을 수행하는 것이 유용함.
  - 정적 분석은 실행을 통해서 확인하는 것이 아니라 명세서의 정확성이나 일관성 등을 확인하거나 분석 도구를 사용해 확인하는 방법. 직접 실행을 통해 확인하는 방법은 동적 분석(Dynamic Analysis)이라고 함.

#### 인수 테스트(Acceptance Tests)

- 사용자가 실제로 사용될 환경에서 요구사항들이 모두 충족되는지 사용자 입장에서 확인하는 과정
- 인수 테스트의 종류에는 사용자 인수 테스트, 운영상의 인수 테스트, 계약 인수 테스트, 규정 인수 테스트, 알파 검사, 베타 검사가 있음.

### 009 UML(Unified Modeling Language)

- UML: 시스템 분석, 설계, 구현 등 시스템 개발 과정에서 시스템 개발자와 고객 또는 개발자 상호간의 의사소통이 원활하게 이루어지도록 표준화한 대표적인 객체지향 모델링 언어.
- UML의 구성 요소에는 사물, 관계, 다이어그램 등이 있음.

#### 사물(Things)

- 모델을 구성하는 가장 중요한 기본 요소. 다이어그램 안에서 관계가 형성될 수 있는 대상들.
  - 구조 사물
  - 행동 사물
  - 그룹 사물
  - 주해 사물(Annotation Things): 부가적인 설명이나 제약조건 등을 표현. 노트(Note).

#### 관계(Relationships)

- 사물과 사물 사이의 연관성을 표현한 것.

#### 연관(Association) 관계

- 2개 이상의 사물이 서로 관련되어 있음을 표현
- 사물 사이를 실선으로 연결하여 표현. 방향성을 화살표로 표현. 양방향일 경우 화살표는 생략.
- 연관에 참여하는 객체의 개수를 의미하는 다중도(Multiplicity)를 선 위에 표기.

#### 집합(Aggregation) 관계

- 하나의 사물이 다른 사물에 포함되어 있는 관계를 표현
- 포함하는 쪽(Whole)과 포함되는 쪽(Part)은 서로 독립적.
- 포함되는 쪽(Part)에서 포함하는 쪽(Whole)으로 속이 빈 마름모를 연결하여 표현

#### 포함(Composition) 관계

- 집합 관계의 특수한 형태로, 포함하는 사물의 변화가 포함되는 사물에게 영향을 미치는 관계를 표현
- 포함하는 쪽(Whole)과 포함되는 쪽(Part)은 서로 독립될 수 없고 생명주기를 함께함.
- 포함되는 쪽(Part)에서 포함하는 쪽(Whole)으로 속이 채워진 마름모를 연결하여 표현

#### 일반화(Generalization) 관계

- 하나의 사물이 다른 사물에 비해 더 일반적인지 구체적인지를 표현함.
- 보다 일반적인 개념을 상위(부모), 보다 구체적인 개념을 하위(자식)이라고 부름.
- 구체적(하위)인 사물에서 일반적(상위)인 사물 쪽으로 속이 빈 화살표를 연결하여 표현

#### 의존(Dependency) 관계

- 연관 관계와 같이 사물 사이에 서로 연관은 있으나 필요에 의해 서로에게 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계를 표현
- 하나의 사물과 다른 사물이 소유 관계는 아니지만 사물의 변화가 다른 사물에도 영향을 미치는 관계
- 영향을 주는 사물(이용자)이 영향을 받는 사물(제공자) 쪽으로 점선 화살표를 연결하여 표현

#### 실체화(Realization) 관계

- 사물이 할 수 있거나 해야 하는 기능(행위, 인터페이스)으로 서로를 그룹화 할 수 있는 관계를 표현
- 속이 빈 점선 화살표

#### 다이어그램(Diagram)

- 사물과 관계를 도형으로 표현한 것
- 정적 모델링에서는 주로 구조적 다이어그램을 사용하고 동적 모델링에서는 주로 행위 다이어그램을 사용

#### 구조적(Structural) 다이어그램의 종류

- 클래스 다이어그램(Class Diagram)
- 객체 다이어그램(Object Diagram)
- 컴포넌트 다이어그램(Component Diagram)
  - 구현 단계에서 사용되는 다이어그램
- 배치 다이어그램(Deployment Diagram)
  - 구현 단계에서 사용되는 다이어그램

#### 복합체 구조 다이어그램(Composite Structure Diagram)

- 패키지 다이어그램(Package Diagram)

#### 행위(Behavioral) 다이어그램의 종류

- 유스케이스 다이어그램(Use Case Diagram)
- 시퀀스 다이어그램(Sequence Diagram)
- 커뮤니케이션 다이어그램(Communication Diagram)
- 상태 다이어그램(State Diagram)
- 활동 다이어그램(Activity Diagram)
- 상호작용 개요 다이어그램(Interaction Overview Diagram)
- 타이밍 다이어그램(Timing Diagram)

https://m.blog.naver.com/qhanfckwsmsd/221554139159

https://roynus.tistory.com/1037

https://morm.tistory.com/88

## 2장. 화면 설계

### 010 사용자 인터페이스 (UI, User Interface)
