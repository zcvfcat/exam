# 정보보안기사

## PART 01 정보보호 개요

### SECTION 01 정보보호관리의 개념

#### 1. 정보화 사회의 정보보호

- 정보보호의 목표
  - 기밀성 - Confidentiality
  - 무결성 - Integrity
  - 가용성 - Availability
  - 인증성 - Authenticity, Authentication
  - 채임추적성 - Accountability

#### 2. 정보보호 관리

#### 3. OSI 보안 구조

보안 공격 (Security Attack)

##### 기밀성을 위혐하는 공격

- 스누핑 (Snooping) : 데이터에 대한 비인가 접근 또는 탈취
- 트래픽분석 (Traffic Analysis)

##### 무결성을 위협하는 공격

- 변경 (메시지 수정, Modification)
- 가장 (Masquerading)
- 재연 (재전송, Replaying)
- 부인 (Repudiation)

##### 가용성을 위협하는 공격

- 서비스 거부(Denial of Service)

##### 소극적 공격과 적극적 공격

- 소극적 공격 (수동적 공격, Passive Attack)
- 적극적 공격 (능동적 공격, Active Attack)
  - 데이터를 바꾸거나 시스템에 해를 입힐 수 있다. 무결성과 가용성을 위협

#### 4. 기본 보안 용어 정의

- 자산 (Asset)
- 취약점 (취약성, Vulnerability)
- 위협 (Threat)
  - 가로채기 (interception) : 기밀성에 영향
  - 가로막음 (interruption) : 가용성에 영향
  - 변조 (modification) : 무결성에 영향
  - 위조 (fabrication) : 무결성에 영향
- 위협 주체(위협원, Threat agents)
- 위험 (Risk)
- 노출 (Exposure)
- 대책/안전장치 (counter-measure / safe-guard)
- 다계층 보안 / 심층방어(Defense in Depth)
- 직무상의 신의성실, 노력 (Due care, Due Diligence)
- 사회공학 (Social Engineering)
- 시점별 통제 (Control)

## PART 02 암호학

### SECTION 02 암호학 개요

#### 1. 암호학의 기본 개념

- 암호와 보안상식
  - 비밀 암호 알고리즘을 사용하지 말 것
  - 약한 암호는 암호화하지 않는 것보다 위험
  - 어떤 암호라도 언젠가는 해독됨
  - 암호는 보안의 아주 작은 부분

#### 2. 암호기법의 분류

##### 치환 암호와 전치 암호

- 치환 암호 (대치 암호, Substitution Cipher)
- 전치 암호 (Transposition Cipher)

##### 블록 암호와 스트림 암호

- 블록 암호 (Block cipher)
- 스트림 암호 (Stream cipher)

##### 위치에 따른 암호화의 구분

- 링크 암호화 (Link Encryption)
- 종단간 암호화 (End-to-End Encryption)

#### 3. 주요 암호기술에 대한 개괄

- 대칭키 암호와 비대칭키 암호
- 하이브리드 암호 시스템
- 일방향 해시 함수
- 메시지 인증코드
- 전자서명
- 의사난수 생성기

#### 4. 암호 분석(암호 해독)

##### 암호 분석의 분류

> ROLE  
> `Eve`는 암호문을 알고 있고, 암호문을 가로챌 수 있다고 가정

- 암호문 단독 공격 (COA, Cipher-text Only Attack)

  - Eve가 단지 어떤 암호문을 얻어서 대응되는 평문과 키를 찾는것

- 기지 평문 공격 (KPA, Known Plain-text Attack)

  - Eve는 해독하려는 암호문 외에 추가로 여러 개의 평문/암호문 쌍을 얻는다.
  - 평문/암호문 쌍은 공격자에게 미리 주어진다.

- 선택 평문 공격 (CPA, Chosen Plain-text Attack)

  - Eve가 평문 / 암호문 쌍을 선택할 수 있다

- 선택 암호문 공격 (CCA, Chosen Cipher-text Attack)
  - Eve가 암호문(알고리즘)을 선택하고 그에 대한 평문을 얻을 수 있다.

#### 5. 암호 알고리즘의 안정성 평가

##### 암호기술 평가

- 평가 종류
  - 암호 알고리즘 평가
  - 암호모듈 평가
  - 정보보호제품 평가
  - 응용시스템 평가

#### 6. 지적 재산권 보호

##### 디지털 저작권 권리

- 스테노가노그래피 (Steganography) : 감추어진 기록
- 디지털 워터마킹 (Digital Watermarking)

  - 원본의 내용을 왜곡하지 않는 법위 내에서 혹은 사용자가 인식하지 못하도록 저작권 정보를 디지털 콘텐츠에 삽입하는 기술

- 핑거프린팅(Finger-printing)

  - 디지털 콘텐츠를 구매할 때 구매자의 정보를 삽입하여 불법 배포 발견 시, 최초의 배포자를 추적할 수 있음
  - 판매되는 콘텐츠마다 구매자의 정보가 들어가므로 불법적으로 재배포된 콘텐츠 내에서 핑거프린팅된 정보를 추출하여 구매자를 식별하고, 법적인 조치를 가할 수 있게 된다.

- 디지털 저작권 관리(DRM, Digital Rights Management)
  - DRM 구성 요서
    - 메타데이터
    - 패키저
    - 시큐어 컨테이너
    - 식별자
    - DRM 제어기
  - DRM 모델
    - 콘텐츠 제공자
    - 콘텐츠 배포자
    - 콘텐츠 소비자
    - 클리어링 하우스(Clearing house)

### SECTION 03 대칭키 암호

#### 1. 현대 대칭키 암호

##### 현대 블록 암호

- 현대 블록암호는 확산과 혼돈과 같은 성질을 만족시키기 위하여 전치 요소(P-박스) 와 치환 요소(S-박스) 그리고 그 밖의 구성 요소를 결합하여 설계된다.
- 블록 암호에 대한 공격
  - 차분 분석 (차분 해독법, Differential Cryptanalysis)
  - 선형 분석 (선형 해독법, Linear Cryptanalysis)
  - 전수 공격법 (Exhaustive key search)
  - 통계적 분석 (Statistical analysis)
  - 수학적 분석 (Mathematical analysis)

##### 현대 스트림 암호

- 추가해야함

#### 2. DES (Data Encryption Standard)

- 평문의 길이는 64bit, 키의 길이는 56bit, 암호문의 길이는 64비트
- 대칭키 블록 암호 알고리즘

##### DES의 취약점

- DES는 평문 또는 키의 작은 변화가 암호문에 큰 변화를 만드는 쇄도효과(Avalanche Effect)가 매우 크고, 암호문의 각 비트가 평문의 많은 비트들에 의존하는 완비성(completeness)이 높은 것으로 증명되어 암호문으로부터 평문을 추론하기가 매우 어렵다
- 그러나 DES는 56비트 키를 사용하므로 최대 키 공간의 크기는 2^56이 되고, 이 수는 DES 개발 당시에는 전사 공격(Brute Force Attack)을 감행할 수 없을 정도로 큰 수 였지만 현대에는 더 이상 전사 공격에 안전하지 못하다.
- 실제로 DES 키는 1998년 3일 만에 전사 공격에 의해 해독되었다. 지긍믕ㄴ 중요 정보의 암호화에는 적용할 수 없는 상태가 되었다.

##### 3중 다중

- 오늘날 보편적으로 사용되는 3중 DES에는 두 가지 버전이 있는데, 하나는 두 개의 키를 갖는 3중 DES이고 다른 하나는 세 개의 키를 같는 3중 DES다.
- 3DES는 하드웨어에서 매우 효율적이지만 소프트웨어에 대해서는 효율적이지 않다. 3DES는 전자 여권에서 바이오 정보를 보호하는데 뿐만 아니라 특히 금융 분야에 많이 사용된다.

###### 3중 DES 현황

- 3DES는 현재도 은행 등에서 사용하고 있지만, 처리 속도는 빠르지 않다. 그래서 과거에 DES로 암호화했던 자료의 호환성을 중시하는 경우를 제외하고는 새로운 용도로 사용하는 경우는 드물다.

###### 두 개의 키를 같은 3중 DES

- 두 개의 키 k1과 k2만을 사용한다.
- 첫번째와 세번째 단계에서는 K1을 사용하고 두번째 단계에서는 k2를 사용한다.
- 중간 단계에서는 복호화 알고리즘을 사용하고, 복호화 과정에서는 암호화 알고리즘을 사용한다.

###### 세 개의 키를 같는 3중 DES

- 두 개의 키를 같은 3DES에 대한 기지 평문공격의 가능성 때문에 어떤 응용프로그램은 세 개의 키를 같은 3DES를 사용한다.
- 세 개의 키를 같은 3DES는 PGP와 같은 많은 응용프로그램에서 사용되고 있다.
- 첫번째, 두번째, 세번째 각각 k1, k2, k3 키를 사용한다.
- 두번째는 복호화 알고리즘을 사용한다.
- 3DES의 복호화는 암호화의 역이 된다. k3, k2, k1의 순으로 복화화 -> 암호화 -> 복호화를 행한다.

###### DES와의 호환성

- 3DES에서 모든 키를 동일하게 하면 3DES는 보통의 DES와 같아진다. 최초의 암호환 -> 복호화로 인해 평문으로 돌아가기 때문이다.
- 과거에 DES로 암호화된 암호문은 3DES를 사용하여 복호화할 수 있다. 즉, 3DES는 DES에 대한 상호호환성을 갖고 있다.

#### 3. AES (Advanced Encryption Standard)

#### 4. 기타 대칭키 암호 알고리즘

##### 국제 암호 알고리즘

- IDEA (International Data Encryption Algorithm)
- RC5

##### 국내 암호 알고리즘

- SEED
- ARIA(Academy Research Institute Agency)
- HIGHT (HIGh security and light weigHT)
  - RFID, USN 등과 같이 저전력, 경량화를 요구하는 컴퓨팅 환경에서 기밀성을 제공하기 위해 2005년 KISA, ETRI 부설연구소 및 고려대가 공동으로 개발한 64비트 블록 암호 알고리즘
- LEA (Lightweight Encryption Algorithm)
  - 빅데이터, 클라우드 등 고속 환경 및 모바일 기기 등 경량 환경에서 기밀성을 제공하기 위해 개발된 128비트 블록암호 알고리즘

#### 5. 현대 대칭키 암호를 이용한 암호화 기범

##### (1) 블록 암호의 사용 방식

- 블록 암호는 고정된 n비트 블록을 n비트 블록으로 변환시키는 함수이다. 임의 길이의 평문을 암호화시키기 위해서는 평문을 특정한 길이로 분할하여 블록 암호에 입력시켜야 한다. 즉, 블록 암호를 이용하여 평문을 암호화 할때 에는 단순히 암호 알고리즘만이 있으면 해결되는 것이 아니고 사용 방식도 규정하여야 한다.
- 블록 암호를 다양한 응용에 사용하기 위해 NIST에서는 5가지 운영 모드를 정의하였다. 이 5가지 모드는 사실상 블록 암호가 사용되는 모든 암호 응용에 적용할 수 있도록 만들어졌다.
- 이 모드는 DES나 AES를 포함한 어떤 대칭 블록 암호에도 적용할 수 있다. 블록 암호의 주요 모드 ECB, CBC, CFB, OFB, CTR모드가 있다.

##### Electronic CodeBook(ECB)모드

- 운영 모드 중에서 가장 간단한 모드는 ECB모드이다. 평문은 N개의 n비트 블록으로 분할된다.
- 만약 평문 크기가 블록 크기의 배수가 아니라면, 평문의 마지막 블록에는 다른 블록들과 동일한 크기로 만들기 위하여 덧붙이기(padding)가 필요하다. 각각의 블록을 암호화 혹은 복호화하기 위하여 사용되는 키는 동일하다.
- ECB모드의 장점은 블록 간의 독립성이다. 다수 블록의 암호화와 복호화를 병렬적으로 수행할 수 있고, 다수 블록 중에 일부 블록만 독립적으로 암호화 할 수 있다. 그리고 블록에서 발생하는 오류가 다른 블록에 영향을 주지 않는다.
- 그러나 ECB 방식은 평문의 블록 패턴과 암호문의 블록 패턴이 동일하게 유지되는 문제점을 안고 있다. 이러한 이유로 동일한 키로 여러 블록의 평문을 암호화 할 떄에는 ECB방식의 사용을 권고하지 않으며, 보통 난 수 발생과 같은 특수한 경우에 사용한다.

```txt
전자 코드 북(Electronic CodeBook, ECB) 모드는 대칭 암호화에서 블록 암호를 사용하여 데이터를 암호화하는 방법 중 가장 간단한 방법입니다.

ECB 모드에서 평문은 고정된 크기의 블록으로 나누어져 각 블록은 독립적으로 암호화됩니다. 이때, 동일한 키와 동일한 알고리즘을 사용하여 암호화를 수행합니다.

하지만 ECB 모드는 두 가지 주요한 단점이 있습니다. 첫째, 동일한 평문 블록에 대해서는 항상 동일한 암호화 결과가 출력되기 때문에, 보안성이 매우 취약합니다. 둘째, 다른 블록과 유사한 패턴을 가진 블록들도 상응하는 유사한 암호화 결과를 출력하기 때문에 암호화 이전의 일부 정보가 유출될 수 있습니다.

그러므로 보다 안전하게 데이터를 암호화하려면 ECB 모드보다 안전한 CBC, CTR, GCM 등의 다른 암호화 모드를 사용하는 것이 좋습니다.
```

##### Cipher Block Chaining(CBC) 모드

- CBC 모드에서 각각의 평문 블록은 암호화 되기 전에 이전 암호문 블록과 XOR된다. 블록이 암호화 될때 암호화된 블록은 전송되지만 다음 블록을 암호화 할 때 사용하기 위하여 메모리에 저장되어야 한다.
- 그리고 첫번째 블록을 암호화 할 때는 이전의 암호문 블록이 존재하지 않으므로, 초기 벡터(IV)라고 불리는 허구의 블록이 사용 된다. 즉, 송신자와 수신자간 사전에 공유한 IV를 존재하지 않는 C0대신에 사용하는 것이다.
- 초기 벡터(IV): 주어진 평문에 대하여, IV의 생성에 앞서 IV는 반드시 송수신 양자 모두가 알고 있어야 하며, 제 3자로 부터의 예측이 불가능해야 한다. 평문과 연관지어 iV에 대한 예측이 불가능해야한다.

```
Cipher Block Chaining(CBC)는 블록 암호화에서 사용되는 대표적인 암호화 모드 중 하나입니다. ECB 모드와 달리, CBC 모드에서는 앞선 블록의 출력 값을 다음 블록의 입력으로 함께 암호화하는 방식을 사용하여 더욱 안전하게 데이터를 암호화할 수 있습니다.

CBC 모드에서는 암호화할 메시지를 블록으로 나누어 처리합니다. 이때, 앞선 블록에서 생성된 암호화 결과 값(Initialization Vector, IV)과 현재 블록의 평문을 XOR 연산한 후, 선택된 대칭키를 사용하여 암호화합니다.

CBC 모드의 IV는 첫 번째 블록에 적용되며, 그 이후의 각 블록은 바로 직전 블록의 암호화 결과 값(IV)을 사용합니다. 따라서 CBC모드에서도 블록 사이즈가 큰 경우 여러 개의 IV 값을 사용할 필요가 있습니다.

CBC 모드는 ECB 모드보다 보안성이 좋으며, 병렬처리를 어렵게 하여 다른 기법들보다 보안성이 높습니다. 그러나 CBC모드도 패딩 오라클 공격(Padding Oracle Attack) 등의 공격에 취약할 수 있다는 문제점이 있어서, 인증이나 HMAC 등의 다른 기법을 추가적으로 사용하여 보완하는 것이 좋습니다.
```

##### Cipher FeedBack(CFB) 모드

- CFB 모드를 이용하면 어떤 블록 암호도 스트림 암호로 바꿀 수 있다. 스트림 암호의 경우 메시지의 길이가 블록의 정수배가 되도록 패딩을 할 필요가 없으며 실시간으로 사용할 수 있다. 따라서 한 문자를 전송하는 경우 문자 중신 스트림 암호를 이용하여 각 문자가 암호화 되는 즉시 전송을 할 수 있다.

```
Cipher Feedback(CFB) 모드는 블록 암호화에서 사용되는 대표적인 암호화 모드 중 하나입니다.

CFB 모드는 앞선 블록의 출력 값을 사용하여 다음 블록을 암호화하는 방식으로 작동합니다. 이전 블록에서 생성된 출력 값(Feedback)은 현재 블록의 평문과 XOR 연산을 수행한 후, 선택된 대칭키를 사용하여 암호화됩니다.

미리 정해진 크기의 스트림 가닥(마치 비밀번호 해싱할 때 Salt와 같이)에 대해서만 사용할 수 있습니다. CFB mode는 stream cipher와 매우 유사하다고 볼 수 있는데, 이 전자는 동기화가 필요하지 않은 반면 CFB mode는 그렇지 않습니다.

CFB 모드는 오류 전파(Propagation Error)의 문제를 겪을 수 있습니다. 즉, 앞선 블록에서 발생한 오류가 후속 블록들에 계속해서 전파되어 올바른 결과도 계산할 수 없게 될 수 있습니다.

따라서, 이러한 문제점이 있어서 CFB 모드보다는 예측 어려운 카운터 모드(CTR)나 검증된 CBC모드 등의 다른 암호화 모드를 사용하는 것이 좋습니다.
```

##### Output FeedBack(OFB) 모드

- OFB 모드는 평문 블록이 동일하면 암호문이 같아지는 ECB모드의 단점과 오류 전파가 발생하는 CBC모드와 CFB모드를 개선한 동작 모드
- OFB 모드 동작은 암호기의 출력과 평문을 EX-OR하여 암호문을 생성하고 있으므로 오류 전파가 발생하지 않는다. 그러나 암호문 송신자와 수신자 사이에 동기를 조절해야 한다. 즉, 전송중인 암호문의 비트 손실이나 삽입 등에 유의해야하는 방식이다.
- OFB 모드에서도 CBC모드나 CFB모드와 마찬가지로 초기화 벡터(IV)를 사용한다. 초기화 벡터는 암호화할 때 마다 다른 랜덤 비트열을 이용하는 것이 보통이다.
- padding이 필요없다.
- 암호화와 복호화가 같은 구조
- 병렬 처리가 불가능

```
OFB(Output Feedback) 모드는 블록 암호화에 사용되는 암호화 모드 중 하나입니다. OFB 모드는 스트림 암호를 생성하기 위한 방법으로 분류됩니다.

OFB 모드에서, 입력 텍스트는 고정 크기의 블록 단위로 나뉘어 처리됩니다. 이전 출력 블록이 다음 블록을 암호화하는 데 사용됩니다. 즉, OFB 모드에서는 이전 출력이 현재 입력과 XOR된 결과가 출력됩니다.

OFB 모드는 일반적으로 선형 흐름 암호화를 구현하는 데 사용됩니다. OFB 모드에서는, 암호화된 키 스트림을 생성하고 이를 평문과 XOR하여 암호문을 생성합니다. 이것은 매우 안전하며, 추측할 수 없는 키 스트림을 생성해 변조 된 메시지로부터 보호합니다.

OFB 모드의 장점은 암호화와 복호화에서 동일한 알고리즘을 사용한다는 것입니다. 그러나 OFB 모드는 오류나 유실 된 데이터를 복구 할 수 없으므로, 전송 중인 데이터에 대한 신뢰성이 필요한 경우 CTR 모드와 같은 다른 모드를 고려해보아야 합니다.
```

##### CounTeR(CTR) 모드

- CTR모드는 암호화 시 피드백이 존재하지 않는다. 그렇지만 키 스트림의 의사난수성은 카운터를 사용함으로써 성취될 수 있다.
- CTR 모드는 OFB 모드와 마찬가지로 이전 암호문 블록과 독립적인 키 스트림을 생성하지만 피드백을 사용하지 않는다. 그리고 ECB 모드처럼 CTR 모드는 서로 독립적인 n비트 암호문 블록을 생성한다.
- padding이 필요없다.
- 암호화, 복호화의 사전 준비가 가능하다.
- 암호화와 복호화가 같은 구조
- 비트 단위의 에러가 있는 암호문을 복화화하면, 평문에 대응하는 비트만 에러가 최단.
- 병렬 처리가 가능하다 (암호화, 복호화 양쪽)

```
CTR(Counter) 모드는 블록 암호화에서 사용하는 대표적인 암호화 모드 중 하나입니다. CTR 모드는 스트림 암호를 생성하기 위한 방법으로 분류됩니다.

CTR 모드에서, 입력 텍스트는 고정 크기의 블록 단위로 나뉘어 처리됩니다. 이전 출력 블록과 nonce라 불리는 일회용 값이 함께 XOR 되어 카운터 값으로 사용됩니다. 이 카운터 값은 다음 블록을 암호화하는 데 사용됩니다. 그런 다음, 이전 출력이 현재 입력과 XOR된 결과가 출력됩니다.

CTR 모드는 OFB 모드와 유사한 방식으로 작동하지만, 다른 장점이 있습니다. CTR 모드는 오류 및 데이터 손실에 대해 보다 안전하며,이러한 문제가 발생하면 일부 메시지 비트만 손실됩니다. 데이터 손실이 복구될 수 있으므로 전송 중인 데이터에 대한 신뢰성이 필요한 경우, CTR 모드가 OFB 모드보다 더 적합합니다.

CTR 모드는 병렬 암호화와 병렬 복호화가 가능하여 OFB보다 더 빠르고 효율적입니다. 그러나 CTR 모드는 악의적인 공격자에게 재사용 공격(replay attack)을 당할 가능성이 있으므로, 이를 예방하기 위해 nonce를 사용해 임의의 카운터 값을 생성하도록 해야합니다.
```

### SECTION 04 비대칭키 암호

#### 1. 비대칭키 암호

#### 2. 하이브리드 암호시스템

### SECTION 05 해시함수와 응용

#### 1. 일방향 해시함수

##### (1) 일방향 해시함수의 개요

- 일방향 해시함수의 특징
  - 임의 길이의 메시지로부터 고정 길이의 해시값을 계산한다.
  - 해시값을 고속으로 계산할 수 있다.
  - 일방향성을 갖는다.
  - 메시지가 다르면 해시값도 다르다

```
일방향 해시 함수(One-Way Hash Function)는 임의 크기의 데이터를 고정된 크기의 해시 값으로 변환하는 알고리즘입니다. 이것은 입력 데이터가 해시 함수를 통해 변환되면 결과 해시 값만 다룰 수 있으며, 원래 데이터는 얻을 수 없다는 것을 의미합니다.

일방향 해시 함수의 특징은 다음과 같습니다.

1. 불변성(Immutability): 일단 해시 값이 계산되면 변경할 수 없습니다. 입력 데이터가 조금이라도 바뀌면 완전히 다른 해시 값이 생성됩니다.

2. 고유성(Uniqueness): 서로 다른 입력 값에 대해 동일한 해시 값이 만들어지는 경우, 충돌(Collision)이 발생한다고 하며, 좋은 해시 함수에서는 이런 충돌 가능성이 매우 적습니다.

3. 단방향성(One-Way Property): 해시 함수는 입력 데이터를 해시 값으로 변환할 수 있지만, 해시 값으로부터 입력 데이터를 복원할 수는 없습니다. 따라서, 원래 데이터는 해시 값을 알더라도 이를 바탕으로 다시 만들거나 역으로 추출할 수 없습니다.

4. 해시 값의 고정 길이(Fixed-length Output): 해시 함수는 입력 데이터의 크기와 상관없이 항상 일정한 크기의 해시 값을 출력합니다.

5. 속도와 안전성(Speed and Security): 좋은 일방향 해시 함수는 빠르면서도 안전한 알고리즘입니다. 그러나 보안을 강화하려면 더 복잡한 해시 함수를 사용해야 하며, 이는 처리 시간이 길어지는 단점이 있습니다.

일반적으로 일방향 해시 함수는 암호화에서 비밀번호를 보호하는 데 많이 사용됩니다.  예를 들면, 사용자의 비밀번호를 일방향 해시 함수로 저장하면, 서버가 실제 비밀번호를 저장하지 않더라도 로그인 요청 시 사용자가 제공한 비밀번호를 해시 함수로 변환하여 저장된 해시 값과 비교하여 인증 처리할 수 있습니다.
```

##### (2) 해시함수의 분류와 보안 요구사항

###### 해시함수의 보안 요구사항

- 프리이미지 저항성 (역상 저항성)
  - 주어진 임의의 출력값 y에 대해 y=h(x)를 만족하는 입력값 x를 찾는 것이 계산적으로 불가능하다.

```
해시 함수의 프리이미지 저항성(Preimage Resistance 또는 역상 저항성)은 주어진 해시 값으로부터 원래 입력 값을 복원하는 것이 어려운 속성입니다. 즉, 일방향성(One-Way Property)과 관련된 개념으로, 단방향 해시 함수가 가진 중요한 속성입니다.

프리이미지 저항성을 가진 해시 함수는 다음과 같은 특징을 갖습니다.

1. 해시 함수의 출력 값만으로는 원래 입력 값을 예측하거나 이를 복원할 수 없습니다.

2. 서로 다른 입력 값에 대해 동일한 해시 값이 만들어질 가능성이 매우 낮습니다.

3. 입력 값이 조금이라도 변경되면, 완전히 다른 해시 값이 생성됩니다.

4. 해시 함수에서 임의의 해시 값은 그것을 만든 입력 값과 전혀 관련이 없는 무작위 데이터처럼 보입니다.

프리이미지 저항성은 해시 알고리즘의 보안성 및 안정성을 평가하기 위한 중요한 기준 중 하나입니다. 이것은 두 가지 유형의 공격을 방지하는 데 도움이 됩니다.

첫째, 유추 공격(Inference Attack)은 해시 값으로부터 입력 값을 추론하려는 공격입니다. 이에 대해 프리이미지 저항성을 가진 경우, 해시 값으로부터 원래 입력 값을 복원하는 것은 매우 어렵습니다.

둘째, 무작위 공격(Random Attack)은 임의의 입력 값을 선택하여 해당 입력에 대한 정확한 해시 값을 찾으려는 공격입니다. 프리이미지 저항성은 무작위 공격에서도 안전함을 보장합니다.

따라서, 좋은 해시 함수는 프리이미지 저항성과 다른 다양한 속성(무결성, 인증, 중복 검사 등)을 모두 갖추어야 합니다.
```

- 제2 프리이미지 저항성 (두번째 역상 저항성, 약한 충돌 내성)
  - 주어진 입력값 x에 대해 h(x)=h(x1), x!=x1을 만족하는 다른 입력밧 x1을 찾는 것이 계산적으로 불가능하다.

```
해시 함수(Hash Function)는 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수입니다. 이때 매핑되는 결과값을 해시값(Hash Value)이라고 합니다.

제2 프리이미지 저항성(Second Preimage Resistance) 또는 두번째 역상 저항성은 주어진 입력값과 다른 입력값 중에서 동일한 해시 값을 가지는 입력값을 찾아내는 것이 어렵다는 성질입니다. 즉, 해시 값이 같은 두 개의 입력값을 찾아내는 작업이 어렵다는 것을 의미합니다.

약한 충돌 내성(Weak Collision Resistance)은 해시 함수의 입력값을 조작하여 동일한 해시 값을 가지도록 만드는 것이 어렵다는 성질입니다. 즉, 이미 주어진 해시 값에 해당하는 입력값을 찾는 작업이 어렵다는 것을 의미합니다.

이러한 제2 프리이미지 저항성과 약한 충돌 내성은 해시 함수의 보안성을 나타내는 중요한 요소 중 하나입니다. 이러한 속성이 높은 해시 함수는 보안성이 강력하며, 암호화 기술 및 메시지 인증 등의 분야에서 사용됩니다.
```

- 충돌 저항성(충돌 회피성, 강한 충돌 내성)
  - h(x)=h(x1)을 만족하는 임의의 두 입력값 x, x1을 찾는 것이 계산적으로 불가능하다F

```
해시 함수(Hash Function)는 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수입니다. 이때 매핑되는 결과값을 해시값(Hash Value)이라고 합니다.

충돌 저항성(Collision Resistance) 또는 충돌 회피성(Preimage Resistance)은 서로 다른 입력값에 대해 동일한 해시 값이 나오는 충돌이 발생하지 않도록 하는 성질입니다. 즉, 어떠한 입력값에 대해서도 그 입력값과 다른 입력값들이 동일한 해시값을 가지는 경우가 드물어야 합니다.

강한 충돌 내성(Strong Collision Resistance)은 주어진 해시 값에 해당하는 서로 다른 입력값을 찾아내는 것이 어렵다는 성질입니다. 즉, 이미 주어진 해시값에 해당하는 입력값들 중에서 서로 다른 입력값을 찾는 작업이 어렵다는 것을 의미합니다.

이러한 충돌 저항성과 강한 충돌 내성은 해시 함수의 보안성을 나타내는 중요한 요소 중 하나입니다. 이러한 속성이 높은 해시 함수는 암호화 기술 및 메시지 인증 등의 분야에서 사용됩니다.
```

##### (3) 키가 없는 해시함수와 키를 사용하는 해시함수

키가 없는 해시함수

- 전용 해시 함수
  - 메시지 다이제스트 (Message Digest) (MD2 -> MD4 -> MD5)

```
메시지 다이제스트(Message Digest)는 주어진 메시지에 대해 고정된 길이의 해시 값을 출력하는 해시 함수입니다. MD2, MD4, MD5는 모두 메시지 다이제스트 알고리즘의 일종입니다.

MD2는 RSA 데이터 보안에서 개발된 128비트 해시 함수로서, 메시지 무결성 검사 등의 용도로 사용됩니다. 단점으로는 보안성이 상대적으로 약하다는 점이 있습니다.

MD4는 MD2보다 안전성이 더 높은 128비트 해시 함수입니다. 그러나 현재는 취약점이 많아 사용되지 않고 있습니다.

MD5는 안전한 128비트 해시 함수 중 하나로 널리 사용됩니다. 파일의 무결성 검사, 암호화 기술 등에 이용됩니다. 그러나 충돌 공격에 취약하다는 문제점이 발견되어 현재는 SHA-256 등 더 안전한 알고리즘이 권장됩니다.

메시지 다이제스트 알고리즘들은 비밀번호나 인증서 등의 중요한 정보를 처리할 때 주로 사용됩니다. 이러한 해시 함수는 입력값을 암호화하여 임의의 길이의 출력값을 만들어냅니다. 따라서 입력값이 조금만 달라져도 출력값이 크게 달라지기 때문에, 입력값이 노출되더라도 원래 값을 복원하는 것이 어렵습니다.
```

- SHA (Secure Hash Algorithm)

```
SHA(Secure Hash Algorithm)는 미국 국가안보국(National Security Agency, NSA)에서 개발한 해시 함수 알고리즘의 일종입니다. 입력값으로 임의 길이의 메시지를 받아 고정 길이의 해시 값을 출력합니다.

SHA 알고리즘은 SHA-1, SHA-2, SHA-3 등 다양한 버전이 있습니다. SHA-1은 160비트의 해시 값을 출력하며, 현재는 보안성에 취약하다고 판단되어 SHA-256, SHA-384, SHA-512 등의 SHA-2 계열 알고리즘이 널리 사용됩니다. 이들은 각각 256비트, 384비트, 512비트의 해시 값을 출력합니다.

SHA 알고리즘은 암호학 분야에서 주로 사용되며, 메시지 무결성 검사, 디지털 서명, 안전한 비밀번호 저장 등에 활용됩니다. 입력값이 조금만 달라져도 출력값이 크게 달라지기 때문에, 입력값이 노출되더라도 원래 값을 복원하는 것이 어렵습니다. 단점으로는 SHA-1 같은 오래된 알고리즘들은 보안성에 취약해져서 요즘은 대부분 SHA-2 나 SHA-3를 사용합니다.
```

- RIPEMD-160

```
RIPEMD-160은 메시지 다이제스트 알고리즘으로서, SHA-1과 유사한 보안 수준을 가지고 있습니다. 하지만 SHA-1의 취약점이 나타나면서 RIPEMD-160이 주로 사용되고 있습니다.

RIPEMD-160은 입력값으로 임의 길이의 메시지를 받아 고정 길이의 160비트 해시 값을 출력합니다. 이 알고리즘은 라이프니츠 주 대학교에서 개발되었으며, 유럽 연합의 프로젝트인 RIPE(RACE Integrity Primitives Evaluation)에서 발표된 것입니다.

RIPEMD-160은 SHA-1보다 안전성이 높기 때문에, 비트코인 등의 가상화폐에서 지갑 주소 생성 등에 활용됩니다. 이외에도 PGP(Pretty Good Privacy) 등에서 사용되어 중요한 데이터를 안전하게 저장하기 위해 사용됩니다.
```

- Tiger

```
Tiger는 강력한 암호화 해시 함수 중 하나입니다. Tiger는 3개의 독립적인 라운드를 가지고 있으며 각 라운드마다 192-bit 키로 구성된 24개의 8x8 S-Box를 사용합니다. Tiger의 출력 값은 192 bit이며, 대부분의 다른 해시 함수보다 더욱 높은 보안 수준을 제공합니다.

Tiger는 메시지 인증 및 디지털 서명 등과 같은 보안 분야에서 광범위하게 사용됩니다. 이러한 분야에서 Tiger는 중요한 역할을 담당하고 있으며, 많은 보안 전문가들이 안전하고 신뢰성 높은 애플리케이션 개발에 Tiger를 사용합니다.
```

- HAVAL

```
HAVAL은 안전한 암호화 해시 함수 중 하나입니다. HAVAL은 보안성이 높으며, 일반적으로 MD5나 SHA-1과 같은 해시 함수보다 안전합니다.

HAVAL은 비트 길이에 따라 세 가지 버전으로 나뉩니다. HAVAL-128, HAVAL-160 및 HAVAL-192는 128비트, 160비트 및 192비트 출력 값을 생성합니다. HAVAL은 3개의 독립된 라운드로 구성되어 있으며, 각 라운드에서는 다양한 비트 연산이 수행됩니다.

HAVAL은 빠르고 안전한 해시 함수이며, 이러한 이유로 파일 무결성 검사 및 메시지 인증 등과 같은 보안 분야에서 광범위하게 사용됩니다. 그러나 최근에는 더욱 강력한 보안 기술이 개발되면서 HAVAL보다 많은 보안 기능을 제공하는 다른 해시 함수들이 대신 사용되기 시작하였습니다.
```

- 블록암호 기반 해시함수

```
블록 암호 기반 해시 함수(Block Cipher Based Hash Function)은 블록 암호를 이용한 암호화 기법으로 구성된 해시 함수입니다. 블록암호는 고정 길이의 블록으로 데이터를 나누어 각각을 암호화하는 방식이며, 이러한 구조를 사용하여 블록 암호 기반 해시 함수가 만들어집니다.

블록 암호 기반 해시 함수는 메시지를 블록 단위로 처리하여 출력 값을 생성하며, 일반적으로 입력 메시지를 여러 번의 라운드(rounds)를 거쳐 처리합니다. 중요한 특징 중 하나는 입력 정보의 추가 또는 수정으로부터 보안이 유지되어야 한다는 점입니다.

대표적인 블록 암호 기반 해시 함수로는 SHA-2(256, 384, 512 bit 등), Whirlpool, Skein 등이 있습니다. 이들 해시 함수는 높은 보안 수준과 안정성을 제공하므로, 주로 비밀번호 저장 및 검증, 메시지 인증, 전자 서명 등과 같은 보안 관련 애플리케이션에서 널리 사용됩니다.
```

- 모듈 연산에 기반을 둔 해시함수

```
모듈 연산에 기반을 둔 해시 함수(Modular Hash Function)는 덧셈, 곱셈 및 모듈로 연산 등의 수학적 연산을 이용하여 해시 값을 생성합니다. 일반적으로 작은 크기의 입력 메시지를 받아서 보다 큰 출력 값을 생성하거나, 입력 메시지와 같은 크기의 출력 값을 생성하는 것이 특징입니다.

가장 대표적인 모듈 연산에 기반을 둔 해시 함수로는 CRC(Cyclic Redundancy Check)와 Adler-32 등이 있습니다. CRC는 16비트, 32비트, 64비트 등 다양한 비트 단위로 메시지의 오류 검출 등에서 사용되며, 비교적 간단한 구조이지만 오류 검출 분야에서 널리 사용됩니다.

Adler-32는 CRC보다 복잡하지만 보안성이 높으며, 파일 동기화, 데이터베이스 검색, 데이터 압축 등의 분야에서 사용됩니다. 이외에도 ELF(Executable and Linkable Format) 파일 포맷에서 사용되는 HAS(Hashed Authentication Code) 등도 모듈 연산에 기반을 둔 해시 함수의 예시입니다.
```

키를 사용하는 해시함수

```
키를 사용하는 해시 함수(Keyed Hash Function)은 메시지 무결성을 보호하기 위해 키(key) 개념이 추가된 해시 함수입니다. 일반적인 해시 함수와 달리, 입력 메시지에 추가로 하나 이상의 비밀 키를 입력으로 받아 해시 값을 생성합니다.

입력 데이터가 같더라도 다른 키 값이 사용되면 서로 다른 출력 결과를 반환하므로, 메시지 인증 및 암호화 분야에서 더욱 안전한 보안 수준을 제공합니다.

대표적으로 HMAC(Hash-based Message Authentication Code), CMAC(Cipher-based MAC) 등이 있습니다. HMAC은 RFC 2104에 정의된 MAC 방식 중 하나로, 해시 함수에 기반하여 메시지 인증 코드(Message Authentication Code)를 생성하는 과정에서 비밀 키를 활용합니다. CMAC은 블록 암호 기반 MAC 방식 중 하나로, 대부분의 경우 AES 알고리즘을 기본으로 사용합니다.

키를 사용하는 해시 함수는 대부분의 경우 상당히 안전한 암호화 기술을 제공하지만, 적절한 키 관리가 이루어지지 않으면 키 유출로 인한 보안 위협이 발생할 수 있으므로 조심해서 사용해야 합니다.
```

##### (4) 암호학적 해시함수의 응용

```
암호학적 해시 함수란 입력값으로부터 고정된 길이의 값인 해시값을 생성하는 함수입니다. 이러한 함수는 일반적인 해시 함수와 다르게, 암호학적 안전성을 보장하기 위한 요구사항을 갖추고 있습니다.

암호학적 해시 함수는 다양한 응용 분야에서 사용됩니다. 가장 일반적인 예로는 비밀번호 저장이 있습니다. 비밀번호를 일방향으로 변환하여 암호화한 후, 이를 데이터베이스나 저장소에 저장합니다. 이때, 일반적인 해시 함수 대신 암호학적 해시 함수를 사용하면 보다 안전한 비밀번호 저장이 가능합니다. 해시값이 노출되더라도 원래 비밀번호를 유추하기가 어렵기 때문입니다.

또한, 디지털 서명이나 메시지 인증 등의 분야에서도 사용됩니다. 암호학적 해시 함수는 해당 데이터가 누구에 의해 생성되었는지를 확인하거나, 해당 데이터가 변경되지 않았는지를 검증하는 용도로 사용됩니다.

하지만, 암호학적 해시 함수를 사용하는 경우에도 반드시 안전한 방식으로 저장 및 관리해야 합니다. 예를 들어 salt 값을 추가하여 보안성을 높이거나, 반복적으로 적용하는 Key Stretching 등의 기술을 적용해야 합니다.
```

- 무결성 점검

```
데이터의 무결성은 해당 데이터가 변조되지 않았음을 보증하는 것으로, 암호학적 해시 함수를 사용하여 무결성을 보장합니다. 파일이나 메시지 등에 대한 해시 값을 생성하고, 이를 전송받은 상대방이 다시 계산하여 일치하는지 확인함으로써 무결성을 검증할 수 있습니다.
```

- 소프트웨어 변경 검출

```
소프트웨어는 종종 변경되기 때문에 원래 코드와 동일한 코드인지 검증해야 합니다. 암호학적 해시 함수를 사용하면, 원래 코드의 해시 값을 저장하고, 실행 시점에 코드의 해시 값을 새로 생성하여 비교함으로써 소프트웨어 변경 여부를 검출할 수 있습니다.
```

- 메시지 인증코드

```
메시지 인증코드는 해당 메시지가 변경되지 않았음을 검증하기 위한 기술입니다. 암호학적 해시 함수를 사용하면, 메시지에 대한 해시 값과 함께 비밀키를 사용하여 인증코드를 생성할 수 있습니다. 이후, 수신자는 메시지와 함께 인증코드를 받아서, 전송자가 보낸 메시지임과 동시에 메시지가 변경되지 않았음을 확인할 수 있습니다.
```

- 전자서명

```
전자서명은 인터넷 상에서 행해지는 다양한 거래에서 사용되는데, 암호학적 해시 함수는 이를 가능하게 합니다. 전자서명에는 전자서명 문서와 함께 생성된 전자서명 값이 포함되는데, 이러한 전자서명 값은 메시지 해시 함수에 대한 개인 키에 의해 생성됩니다. 이렇게 생성된 전자서명 값은 문서의 변조 여부를 검증할 수 있습니다.
```

##### (5) 랜덤 오라클 모델과 해시함수에 대한 공격

###### 랜덤 오라클 모델

```
랜덤 오라클 모델(Random Oracle Model)은 암호학에서 사용되는 해시 함수의 안전성 분석을 위한 모델입니다. 해시 함수를 무작위 함수로 가정하고 해당 함수의 입력과 출력 간의 1:1 대응관계를 보장하는 것이 핵심 아이디어입니다.

랜덤 오라클 모델의 이름에서 "오라클"이란 용어는 입력값에 대한 출력값을 반환하는 함수를 말합니다. 이 함수는 완벽히 무작위한 값으로 구현되며, 매번 같은 입력값에 대해서는 동일한 출력값을 반환합니다. 이러한 특징 때문에 랜덤 오라클 모델은 해시 함수로써의 보안성을 분석할 때 매우 유용하게 사용됩니다.

랜덤 오라클 모델을 사용하면, 적절한 크기의 입력공간을 가지는 해시 함수로부터 생성된 출력값의 무작위성과 균등성을 분석할 수 있습니다. 이를 기반으로 다양한 해시 함수 공격에 대한 대처 방안을 마련하거나, 해시함수 디자인에 대한 지침을 제공할 수 있습니다.

하지만, 랜덤 오라클 모델은 단순화된 모델이기 때문에 실제 해시 함수의 동작과 완전히 일치하지 않을 수 있습니다. 따라서, 랜덤 오라클 모델에서 얻은 결과를 대입하여 보안성을 보장하는 것은 쉽지 않을 수 있습니다.
```

###### 일방향 해시함수에 대한 공격

- 무차별 공격
  - '약한 충돌 내성'을 깨고자 하는 공격

```txt
일반적으로 일방향 해시함수는 비밀번호 암호화, 전자서명 등에서 사용되며, 해시 결과값으로 원본 데이터를 식별할 수 없어 보안에 강합니다. 그러나, 무차별 공격을 통해 해시값 충돌을 발생시켜 보안을 깨는 경우가 있습니다.

무차별 공격
무차별 공격은 해시 함수의 정의에 따라 임의의 입력 값에 대해 출력 값을 계산하는 공격입니다. 이 방법은 매우 단순하지만, 시간과 컴퓨팅 파워를 많이 소모하므로 일반적으로 작은 크기의 해시 함수에 대해서만 적용됩니다.

‘약한 충돌 내성’을 깨고자 하는 공격
약한 충돌 내성(weak collision resistance)은 상당히 높은 충돌 확률을 가지고 있는 것을 의미합니다. 공격자는 약한 충돌 내성을 가진 해시 함수를 대상으로 빈번하게 충돌을 발생시켜 보안을 깨려 합니다. 예를 들어, 패스워드가 “password”인 경우와 “admin”인 경우 충돌 여부를 확인하여 패스워드를 조작할 수 있습니다. 이러한 공격을 예방하기 위해서는 충돌 확률이 매우 낮은 안전한 해시 함수를 사용해야 합니다.
```

- 기타 해시함수 공격의 종류와 특성
  - 일차블록 연쇄공격
  - 중간자 연쇄공격
  - 고정점 연쇄공격
  - 차분 연쇄공격

```t
해시 함수는 임의의 길이의 입력 데이터를 고정된 크기의 데이터로 매핑하는 함수입니다. 그러나 해시 함수는 충돌을 생성할 가능성이 있어서 입력 데이터에 대해 유일한 출력값을 보장하지 않습니다.

따라서 악의적인 사용자들은 이러한 충돌을 활용하여 다양한 해시 함수 공격 기술을 개발하였습니다. 그중에서 일차블록 연쇄공격, 중간자 연쇄공격, 고정점 연쇄공격, 차분 연쇄공격 등이 있습니다.

일차블록 연쇄공격 (birthday attack): 서로 다른 두 입력 데이터가 동일한 해시 값을 가질 확률이 생각보다 높은 것을 이용하는 공격 방법입니다. 이 경우 약 2^(n/2)번의 시도만으로 충돌을 발생시킬 수 있습니다. 이 공격 방법은 해시 함수의 비트수 n이 작을 경우에 효과적입니다.

중간자 연쇄공격 (man-in-the-middle attack): 중간자 공격은 해시 함수를 무력화시켜 오동작을 유도하는 방법입니다. 해시 운영자에게서 결과값을 빼앗아 자신이 원하는 값을 넣고 메시지를 전송합니다. 이 공격 방법은 암호체계에서 많이 사용됩니다.

고정점 연쇄공격 (fixed-point attack): 고정점 공격은 특정 실행 조건이 만족되었을 때 특정 입력에 대한 해시 결과값이 고정된 경우를 이용하는 방법입니다. 이 경우 고정점 근처이며 서로 다른 입력 데이터를 찾아가면서 고정점 값을 찾습니다.

차분 연쇄공격 (differential attack): 차분 공격 방법은 서로 다른 입력 데이터의 차이에 따라서 출력 값이 어떻게 변경되는지를 분석하여 공격하는 방법입니다. 이 공격 방법은 입력 데이터에 대한 미세한 차이까지 검사하기 때문에 보다 강력하게 작동할 수 있습니다.

위와 같은 해시 함수 공격 기술들은 악의적인 사용자에 의해 시도되기 때문에, 개발자는 안전하고 강력한 해시 함수를 사용하고, 그 방식을 충분히 검증해야 합니다.
```

##### (6) 일방향 해시함수로 해결할 수 없는 문제

- 일방향 해시함수는 '조작과 변경'을 검출할 수는 있지만 거짓행세를 검출하지는 못한다.
- 파일의 무결성을 조사하는 것뿐만 아니라 이 파일이 정말로 앨리스의 것인가를 확인하고 싶은 경우에는 무결성 외에 인증이라는 절차가 필요해진다.
- 인증을 수해하기 위한 기술이 메시지 인증코드와 전자서명이다.

#### 2. 암호학적 해시함수의 예

#### 3. 메시지 인증코드(MAC, message Authentication Code)

- 메시지 인증코드(MAC)란 무결성을 확인하고 메시지에 대한 인증을 하는 기술
- MAC을 사용하면 변경과 거짓행세 검출이 가능하다.
- 메시지 인증코드는 임의 길이의 메시지와 송신자 및 수신자가 공유하는 키라는 2개의 입력을 기초로 해서 고정 비트길이의 출력을 계산하는 함수이다. 이 출력은 MAC값이라 부른다.
- MAC의 한 가지 장점은 블록 암호나 해시 함수에 기반을 두기 때문에 전자 서명보다 훨씬 빠르다는 것.

```t
MAC은 메시지 인증코드(Message Authentication Code)의 약자로, 메시지에 대한 무결성을 확인하고 인증하기 위한 기술입니다. 이는 메시지가 변경되지 않았으며, 정당한 송신자에 의해 보내진 것임을 보장하기 위해 사용됩니다. MAC은 대칭키 암호화 기술을 사용하여 생성되며, 암호화된 메시지와 함께 전송됩니다. 수신자는 이를 복호화하여 원본 메시지와 비교함으로써 무결성과 인증을 확인할 수 있습니다. 이를 통해 중간자 공격과 같은 보안 위협으로부터 안전한 통신이 가능해집니다.
```

##### (3) MAC에 대한 공격

- 재전송 공격
- 재전송 공격을 막을 수 있는 방법은 순서번호, 타임스탬프, 비표, 시도/응답 등이 있다.

```t
MAC에는 재전송 공격(Replay Attack)이라는 보안 위협이 존재합니다. 재전송 공격은 정당한 송신자가 보낸 MAC값을 가로채서 다시 전송하는 것입니다. 해커는 이를 통해 수신자가 이전에 받은 메시지와 같은 내용의 메시지를 보내어 공격할 수 있습니다.

재전송 공격을 막기 위해서는 다양한 방법들이 제안되어 있습니다. 먼저, 순서번호나 타임스탬프를 이용하여 메시지의 시간 순서를 확인하고 중복된 메시지인지 확인할 수 있습니다. 비표(Nonce)는 한 번만 사용되는 임시 값으로, 매번 달라지는 난수 값을 MAC값과 함께 전송함으로써 재전송 공격을 막을 수 있습니다.

또한, 시도/응답 방식을 사용하여 재전송 공격을 막을 수 있습니다. 이 경우, 수신자는 요청한 작업에 대한 응답을 받아야만 다음 동작을 수행할 수 있습니다. 따라서, 이전에 받은 응답과 같은 내용의 메시지를 보내어도 새로운 응답이 필요하기 때문에, 재전송 공격이 방지됩니다.

종합적으로, MAC의 안전성을 확보하기 위해서는 재전송 공격을 막을 수 있는 적절한 방법들을 사용해야 합니다.
```

##### (4) MAC으로 해결할 수 없는 문제

- 제 3자에 대한 증명
- 부인방지(non-repudiation)
- 전자서명을 사용하면 제 3자에 대한 증명과 부인방지가 가능해진다.

```t
MAC은 주로 무결성과 인증을 위해 사용되며, 제 3자에 대한 증명이나 부인방지와 같은 보안 요구사항에는 한계가 있습니다. 이는 MAC이 대칭키 암호화 기술을 사용하기 때문인데, 송신자와 수신자가 서로 같은 비밀키를 공유하기 때문입니다.

따라서, 제 3자에 대한 증명과 부인방지를 위해서는 전자서명과 같은 공개키 암호화 기술이 필요합니다. 전자서명은 비대칭키 암호화 기술을 사용하여 생성됩니다. 전자서명을 사용하면, 메시지를 보낸 사람의 신원을 확인할 수 있으며, 송신자가 부인할 수 없는 증거를 제공합니다.

전자서명은 주로 인터넷 트랜잭션, 법적 문서, 계약서 등에서 사용되며, 제 3자에 대한 증명과 부인방지가 필수적인 경우에는 MAC보다 더욱 안전한 방법입니다. 결론적으로, MAC은 무결성과 인증을 해결하는 보안 기술이며, 전자서명은 제 3자에 대한 증명과 부인방지와 같은 추가적인 보안 요구사항을 해결하는 기술입니다.
```

#### SECTION 06 전자서명과 PKI

##### 1. 전자서명

```t
전자서명(Electronic Signature)은 전자적으로 생성된 서명으로, 디지털 문서에 실제 서명을 대신하여 사용할 수 있는 기술입니다. 전자서명은 법적으로 자격이 부여된 CA(Certification Authority)가 발급한 디지털 인증서를 사용하여 만들어집니다.

전자서명 시스템은 일반적으로 다음과 같은 단계로 이루어집니다.

1. 서명 요청: 전자서명을 하기 위해 송신자는 먼저 서명 요청을 생성합니다.

2. 인증서 발급: 송신자의 신원을 확인하고, CA에서 디지털 인증서를 발급받습니다.

3. 서명 생성: 디지털 인증서와 함께 송신자의 개인키를 사용하여 서명을 생성합니다.

4. 서명 검증: 수신자는 디지털 인증서를 사용하여 전자서명의 유효성을 검증합니다.

전자서명은 기존의 종이 문서 서명 방식과 동일한 법적 효력을 가지며, 보안적으로 안전하게 전송될 수 있습니다. 또한, 전자서명을 사용함으로써 문서 작성 및 관리가 용이해지며, 업무 프로세스의 자동화 및 효율화에도 기여합니다.

하지만, 전자서명 또한 보안 위험이 존재할 수 있으므로, 안전한 전자서명 시스템을 사용하는 것이 중요합니다. 따라서, 전자서명을 도입하려는 기업이나 단체는 보안 및 법적인 측면에서 조심스러운 검토가 필요합니다.
```

##### 2. PKI(공개키 기반 구조)

```
PKI(공개키 기반 구조, Public Key Infrastructure)는 대칭키 암호화 기술의 한계를 극복하기 위해 개발된 보안 인프라입니다. PKI는 공개키 방식의 암호화 기술을 사용하여 안전한 정보 교환 및 인증 기능을 제공합니다.

PKI 시스템은 다음과 같은 주요 요소로 구성됩니다.

1. 공개키: 공개키는 모두에게 공개되어 있으며, 이를 사용하여 메시지를 암호화할 수 있습니다. 공개키는 인증서로부터 가져올 수 있으며, 매우 긴 길이를 가지므로 짧은 세션키를 암호화하는 데 사용됩니다.

2. 개인키: 개인키는 개인적으로 보관되며, 해당 사용자만 접근할 수 있습니다. 개인키는 공개키와 쌍을 이루며, 메시지를 복호화하거나 전자서명을 생성하는 데 사용됩니다.

3. 인증기관: 인증기관(Certificate Authority, CA)은 공개키를 발급하고 관리하는 담당 기관입니다. 인증기관은 고객이 신원을 확인하고, 디지털 인증서를 발급하여 공개키를 인증합니다.

4. 디렉터리: 디렉터리는 인증서 및 공개키와 관련된 정보를 저장하는 데이터베이스입니다.

PKI 시스템은 매우 안전한 암호화 방식으로, 전자서명, 인증, 보안 이메일 등 다양한 보안 서비스에서 사용됩니다. 하지만, PKI 시스템도 일부 취약점을 가지고 있기 때문에, 시스템의 보안성을 유지하기 위해서는 주기적인 보안 업데이트 및 검토가 필요합니다.
```

#### SECTION 07 키, 난수

##### 1. 키

##### 2. 난수

## PART 03 접근통제

### SECTION 08 접근통제 개요

#### 1. 접근통제 개요

```
데이터나 시스템에 접근할 수 있는 권한을 관리하는 것을 정보보안 접근 통제라고 합니다. 이를 통해 비인가자가 데이터나 시스템에 접근하는 것을 방지하고, 인가된 사용자도 필요한 데이터와 시스템만 접근할 수 있도록 제어합니다.

접근 통제는 크게 식별, 인증, 권한 부여로 구성됩니다. 식별은 사용자의 신원을 확인하는 과정이며, 대표적인 예시로는 아이디와 비밀번호 기반의 로그인이 있습니다. 인증은 식별된 사용자가 실제로 그 사용자인지 확인하는 과정으로, 즉 사용자가 제대로 된 권한을 갖추고 있는지를 검증하는 작업입니다. 마지막으로 권한 부여는 인증된 사용자에게 해당 데이터나 시스템에 접근 가능한 권한을 주는 것입니다.

정보보안 접근 통제를 효과적으로 구현하기 위해서는, 먼저 사용자들의 역할과 권한을 정의하고 그에 맞게 권한 부여를 해야 합니다. 또한 이러한 접근 통제의 로그를 기록하여 보류 및 조사 목적으로 확인할 수 있도록 해야 합니다. 이 외에도 최신 보안 기술을 적용하고 교육 등의 노력을 통해 사용자들의 인식 개선에도 주력해야 합니다.
```

### SECTION 09 사용자 인증

#### 1. 인증

#### 2. 사용자 인증 기법

#### 3. 통합 인증 체계(SSO, Single Sign On)

```
1. **인증(Authentication)**: 사용자가 시스템이나 애플리케이션 등에 접속할 때, 그 사용자의 신원을 확인하는 과정입니다. 사용자가 제공한 정보(아이디와 비밀번호, 생체 인식 정보, 인증서 등)를 검증하고, 해당 사용자가 정당한 사용자인지 여부를 판단하여 인증합니다.

2. **사용자 인증 기법**: 대표적인 사용자 인증 기법으로는 아래와 같은 것들이 있습니다.

- 아이디와 비밀번호(Login ID and password): 가장 일반적인 방법으로, 사용자가 사전에 등록한 아이디와 비밀번호를 입력하여 인증합니다.
- 바이오 인증(Biometric authentication): 지문, 안면 인식, 홍채 등과 같은 생체 정보를 이용해서 인증합니다.
- OTP(one-time password): 일회성 비밀번호로, 매번 새롭게 생성되는 임시 비밀번호를 이용해 인증합니다.
- 카드키(Card-key): 카드 형태의 키카드 등을 이용해서 인증합니다.
- 인증서(Authentication certificate): 전자 인증서를 발급받아 해당 인증서를 이용해 인증합니다.

3. **통합 인증 체계(SSO, Single Sign-On)**: 다수의 시스템이나 애플리케이션 등에 접속해야 하는 경우, 각각의 시스템마다 로그인을 반복해서 해야하는 불편함을 줄이기 위한 인증 기법입니다. SSO를 사용하면 한 번 로그인하여 계정 정보를 저장해두면, 다른 시스템에서도 자동으로 인증이 처리됩니다. 사용자는 같은 계정으로 여러 서비스를 이용할 수 있으며, 보안성도 향상됩니다. 엔터프라이즈 환경에서 많이 사용되는데, 예를 들어 회사 내부에서 사용되는 다양한 애플리케이션들에 대해 SSO를 구현하여 직원들이 로그인을 반복하지 않아도 되도록 할 수 있습니다.
```

### SECTION 10 접근통제 보안 모델

#### 1. 접근통제의 모델

```
접근 통제 모델은 시스템에 대한 접근 권한을 결정하고 관리하기 위해 사용하는 일련의 규칙이나 체계입니다. 주로 세 가지 모델이 사용됩니다.

1. **DAC (Discretionary Access Control)**: 소유자가 파일과 디렉터리에 대한 액세스를 제어하는 모델입니다. 이 모델에서는 사용자가 파일의 소유자일 경우 해당 파일에 대한 액세스 권한을 부여할 수 있습니다. 즉, 파일의 소유자가 파일의 읽기, 쓰기 및 실행 권한을 설정하고, 필요에 따라 이러한 권한을 다른 사용자 또는 그룹에게 부여할 수 있습니다. 하지만 DAC는 보안성이 낮고 혼란스럽기 때문에 엄격한 보안 기준이 요구되는 환경에서는 권장되지 않습니다.

2. **MAC (Mandatory Access Control)**: 시스템 자체적으로 강제적인 규칙에 따라 액세스를 제어하는 모델입니다. 이 모델에서는 관리자가 만든 정책이나 규칙에 따라 사용자에게 액세스 권한을 부여합니다. 예를 들면 계급이나 암호 등의 보안 수준에 따라 각 사용자는 파일에서 데이터를 읽거나 쓸 수 있습니다. MAC 방식은 일반적으로 DAC 방식보다 보안성이 높고 안전하지만, 유저 그룹마다 권한 부여가 어려워 시스템 관리자가 모든 권한을 제어해야 한다는 단점이 있습니다.

3. **RBAC (Role-Based Access Control)**: 역할 기반 접근 통제로도 알려진 RBAC은 사용자의 직무나 역할에 기초해서 액세스 권한을 부여하는 모델입니다. 이러한 구조에서는 사용자에게 역할이 할당되며, 각 역할은 일련의 권한 관련 작업 목록과 연관됩니다. 예를 들어 회사의 IT 관리자에게는 전체 네트워크 및 서버에 대한 액세스가 부여되지만, 일반 사용자에게는 제한된 액세스만 부여될 수 있습니다. 보안성과 관리 용이성면에서 가장 유용하고 권장되는 모델입니다.
```

#### 2. 보안 모델

```
보안 모델은 시스템의 보안을 유지하기 위한 일련의 규칙, 절차 및 역할로 된 체계입니다. 시스템 보안을 유지하고 관리하는 데 중요한 역할을 합니다.

보안 모델은 다음과 같이 분류됩니다.

1. **DAC (Discretionary Access Control)**: 소유자가 파일과 디렉터리에 대한 액세스를 제어하는 모델입니다. 이 모델에서는 사용자가 파일의 소유자일 경우 해당 파일에 대한 액세스 권한을 부여할 수 있습니다.

2. **MAC (Mandatory Access Control)**: 시스템 자체적으로 강제적인 규칙에 따라 액세스를 제어하는 모델입니다.

3. **RBAC (Role-Based Access Control)**: 사용자의 직무나 역할에 기초해서 액세스 권한을 부여하는 모델입니다.

4. **TE (Trusted Execution)**: 보안 커널에서 제공되는 방식으로, 보안 커널이 실행하는 코드와 데이터에만 액세스할 수 있는 보안성을 제공합니다.

5. **MLS (Multilevel Security)**: 여러 보안 수준이 있는 환경에서 사용됩니다. 예를 들어, 비밀 정보의 등급이 높은 데이터와 낮은 등급의 데이터가 동시에 존재하는 경우, 보안 등급에 따라 데이터에 대한 액세스 권한이 결정됩니다.

6. **Bell-LaPadula 모델**: 미국의 학자들인 Bell과 La Padula가 제안한 개념으로, 기밀성을 보장하기 위해 사용됩니다. 이 모델은 사용자가 단계적으로 정의된 보안 수준보다 높아지지 않도록 제한합니다.

7. **Biba 모델**: 미국 컴퓨터 과학자 Biba가 제안한 보안 모델입니다. 신뢰할 수 없는 객체로부터 신뢰 있는 객체를 보호하기 위해 사용됩니다.

8. **Clark-Wilson 모델**: 시스템에서 데이터 무결성을 유지하기 위해 사용되며, 데이터를 접근할 수 있는 두 가지 메커니즘인 변환 프로시저와 액세스 제어 리스트를 사용하여 시스템 자원을 보호합니다.

이러한 보안 모델 중에서는 시스템의 요구 사항에 맞게 선택하여 구현하도록 해야 합니다.
```

### SECTION 11 접근통제 보안위협 및 대응책

#### 1. 접근통제 보안위협 및 대응책

```
접근통제는 인가된 사용자만이 시스템에 접근할 수 있도록 하는 보안 메커니즘이며, 이를 관리하지 않으면 불법적인 사용자가 시스템에 침입하여 중요한 데이터를 훔치거나 변조할 수 있습니다.

접근통제의 위협으로는 불법적인 접근, 권한남용, 내부자에 의한 정보유출 등이 있습니다. 이러한 위협을 방지하기 위해 다음과 같은 대응책이 있습니다.

1. 암호화: 사용자 계정, 비밀번호, 데이터 등을 암호화하여 보안성을 높입니다.

2. 2단계 인증: 사용자가 로그인하기 위해 비밀번호 외에 추가적인 인증 과정을 거치도록 합니다.

3. 권한 관리: 사용자들에게 필요한 최소한의 권한만 부여하여 권한 남용을 방지합니다.

4. 로깅 및 모니터링: 시스템의 모든 활동을 기록하고 감시하여 불법적인 접근 시 즉각적인 조치를 취할 수 있습니다.

5. 업데이트와 패치: 보안 취약점을 수정하기 위한 업데이트와 패치를 수시로 진행하여 보안성을 유지합니다.

6. 교육 및 인식: 사용자들에게 보안 위협에 대한 교육과 인식을 제공하여 안전한 컴퓨터 사용 습관을 만듭니다.

이러한 접근통제의 대응책을 모두 적용함으로써 시스템 보안을 강화할 수 있습니다.
```

PART 04 시스템 보안

### SECTION 12 보안 운영체제

#### 1. 보안 운영체제 개요

```
보안 운영체제는 보안성을 강화한 운영체제로, 시스템의 보안성을 높이기 위해 설계된 운영체제입니다. 일반적인 운영체제와 달리 사용자 인증, 권한 관리, 파일 및 데이터 암호화 등 안전한 기능을 제공하며, 보안상 취약한 기능은 비활성화되어있습니다.

보안 운영체제의 특징은 다음과 같습니다.

1. 사용자 인증: 접근통제를 강화하기 위해 사용자 인증 구조가 강화되어 있습니다.

2. 권한 관리: 최소한의 권한만 부여하여 권한남용을 방지하기 위해 권한 관리 기능이 강화되어 있습니다.

3. 가상화: 사설 클라우드 관련 서비스로 추가로 지원하는 것으로 다양한 모니터링 및 접근통제 등 보안 기술을 내장합니다.

4. 로깅 및 감사: 시스템 로그인, 파일 접근, 네트워크 연결 등 모든 활동을 기록하고 감시하여 불법적인 접근 시 대응할 수 있도록 합니다.

5. 미끼 프로세스(Misdirection): 해커가 공격하려는 시스템을 가상의 시스템으로 만들어 해당 시스템에 대한 정보만 수집하게 합니다.

6. 데이터 암호화: 중요한 데이터에 대해 암호화 기능을 제공함으로써 정보 유출을 방지합니다.

이러한 보안 운영체제를 사용함으로써 기업의 민감한 정보를 안전하게 관리하고 보호할 수 있습니다. 하지만, 보안성 향상을 위해 많은 기능이 추가적으로 탑재되기 때문에 일반적인 운영체제보다 높은 하드웨어 성능과 별도의 보안관리 능력이 필요합니다.
```

#### 2. 보안 운영체제의 주요 제공 기능

```
보안 운영체제의 주요 제공 기능은 다음과 같습니다.

1. 인증 및 권한 관리: 사용자 인증 과정을 강화하여 불법적인 로그인을 방지하며, 최소한의 권한만 부여하여 권한 남용을 예방합니다.

2. 파일 및 데이터 암호화: 중요한 파일이나 데이터를 암호화하여 보호합니다.

3. 접근통제: 인가된 사용자만이 시스템 리소스에 접근할 수 있도록 제어합니다.

4. 취약점 분석 및 보완: 시스템 내부의 취약점을 검사하여 보완 조치를 취합니다.

5. 보안 로깅: 사용자 활동 및 시스템 이벤트를 로그로 기록하여 보안상 문제가 발생했을 때 추적할 수 있습니다.

6. 바이러스 백신 및 방화벽: 바이러스나 해킹 등의 사이버 공격으로부터 시스템을 보호하기 위해 바이러스 백신이나 방화벽을 탑재합니다.

7. 가상화 기술: 서버 가상화 기술을 통해 하나의 서버를 여러 개의 가상 서버로 분할하여 보안성을 높입니다.

8. 미끼 프로세스: 보안 운영체제 내에서 미끼 프로세스를 생성하여 해커가 시스템을 침입할 때 가상의 시스템에 접근하도록 유도합니다.

9. 자동화된 보안 업데이트: 보안 운영체제의 취약점이 발견되면 이를 자동으로 업데이트하여 보안성을 유지합니다.

이러한 주요 제공 기능들은 보안 운영체제가 높은 보안성을 제공하는 이유입니다.
```

#### 3. 보안 운영체제와 보안커널

```
보안 운영체제와 보안 커널은 서로 다른 개념입니다.

보안 운영체제(Secure Operating System)는 보안성을 강화한 운영체제로, 시스템의 보안성을 높이기 위해 설계된 운영체제입니다. 기존의 운영체제에 추가적인 보안 기능을 제공하거나 수정하여 만들어진 것으로, 사용자 인증, 권한 관리, 파일 및 데이터 암호화 등 안전한 기능을 제공하며, 보안상 취약한 기능은 비활성화되어있습니다.

반면, 보안 커널(Security Kernel)은 운영체제 내에서 가장 중요한 부분으로, 시스템 자원에 대한 접근과 사용 권한을 관리합니다. 이를 통해 보안성을 강화하며, 외부에서의 침입과 공격에 대한 방어도 가능합니다.

따라서, 보안 운영체제는 일반적인 운영체제에 추가적인 보안 기능이 탑재된 것이라면, 보안 커널은 운영체제 내에서 가장 핵심적인 보안 기능을 담당하는 역할을 합니다.
```

#### 4. 신뢰 플랫폼 모듈(TPM: Trusted Platform Module)

```
먼저 TPM은 Trusted Computing Group에서 만든 스펙으로, 컴퓨터의 보안을 강화하는 역할을 합니다. TPM 칩은 컴퓨터의 부팅 과정에서 하드웨어적으로 루팅되어, 시스템에 대한 다양한 보안 서비스를 제공합니다.

TPM의 기능으로는 다음과 같은 것들이 있습니다.

- 키 관리: TPM 칩 안에는 고유한 키 쌍이 저장되어 있으며, 이를 사용하여 디스크 암호화나 인증 등과 같은 보안 서비스를 제공합니다.
- 임의 숫자 생성: 컴퓨터 내부에서 안전하게 난수를 발생시켜 프로그램이나 서버에서 사용할 수 있습니다.
- 플랫폼 측정: TPM은 부팅, 실행 중인 OS 및 애플리케이션의 상태를 측정하여 무결성 검사를 수행합니다. 이를 통해 변경된 코드나 악성 코드 탐지가 가능합니다.

TPM은 최신 컴퓨터 시스템에서 널리 사용되고 있으며, 비밀 정보 유출 등의 보안 사고로부터 시스템을 보호하는 데 큰 역할을 합니다.
```

### SECTION 13 클라이언트 보안

#### 1. 악성 소프트웨어(악성 코드)

```
악성 소프트웨어(악성 코드)는 컴퓨터나 네트워크에 대한 악의적인 의도를 가지고 작성된 소프트웨어를 말합니다. 이러한 악성 코드는 사용자의 동의 없이 설치되거나 실행될 수 있으며, 시스템의 정상적인 동작을 방해하거나 사용자의 개인정보를 탈취하는 등 다양한 악의적인 목적으로 사용됩니다.

악성 코드는 크게 바이러스, 트로이 목마, 웜, 스파이웨어, 어드웨어 등 다양한 종류가 있습니다. 각각에 대한 설명은 다음과 같습니다.

- 바이러스: 일반적으로 다른 프로그램에 감염되어 전파되는 악성 코드입니다. 감염된 프로그램이 실행될 때마다 바이러스도 실행되어 컴퓨터 시스템에 해를 끼칩니다.
- 트로이 목마: 신뢰할 만한 것처럼 위장하여 다운로드나 설치를 유도하면서 컴퓨터나 네트워크를 침입하고 제어하는 악성 코드입니다.
- 웜: 스스로 복제하여 전파하는 악성 코드입니다. 네트워크를 통해 웜이 전파될 경우, 컴퓨터 시스템의 리소스가 고갈되는 등의 문제를 일으킬 수 있습니다.
- 스파이웨어: 사용자의 정보를 탈취하거나 불법적인 목적을 위해 설치된 프로그램입니다. 주로 광고나 개인정보를 수집하는 데 사용됩니다.
- 어드웨어: 광고 목적으로 설치되는 프로그램으로, 사용자에게 광고 팝업 창을 띄우거나 보안이 취약한 광고 링크로 연결하는 등의 악성 행위를 합니다.

이러한 악성 코드로부터 컴퓨터를 보호하기 위해서는 백신 프로그램, 방화벽 등 다양한 보안 솔루션을 적용하여 사용자들이 안전한 인터넷 환경에서 작업할 수 있도록 지원하는 것이 중요합니다.
```

#### 2. 인터넷 활용 보안

```
인터넷 활용 보안은 인터넷을 사용할 때 발생할 수 있는 다양한 위협으로부터 개인정보와 시스템을 안전하게 보호하기 위해 취해야 하는 조치입니다.

가장 기본적인 방법은 안티바이러스 소프트웨어와 방화벽을 설치하는 것입니다. 안티바이러스는 악성코드나 스파이웨어 등의 위협으로부터 컴퓨터를 보호합니다. 또한 방화벽은 인터넷과 로컬 네트워크 간의 데이터 흐름을 제어하여 외부로부터의 공격을 막아줍니다.

또한, 패치 관리도 중요합니다. 패치는 운영 체제와 응용 프로그램에서 발견된 보안 취약점을 수정하는 역할을 합니다. 따라서 최신 버전의 보안 패치를 설치하면 보안에 대한 위협을 줄일 수 있습니다.

암호화 기술도 인터넷 활용 보안에 큰 역할을 합니다. HTTPS 프로토콜을 사용하여 인터넷 상에서 데이터를 전송할 때 SSL 인증서를 사용하여 데이터를 암호화할 수 있습니다. 또한, 이메일 전송 시에도 SMTPS(SMTP over SSL)나 STARTTLS 등의 암호화 기술을 사용하여 데이터를 전송할 수 있습니다.

마지막으로, 사용자 교육도 중요합니다. 사용자는 악성코드나 스팸 메일과 같은 위협에 대한 인식을 가지고, 트래픽 분석 도구와 불법 사이트 차단 프로그램 등을 사용하면서 안전한 인터넷 환경에서 작업할 수 있도록 지원하는 것이 필수적입니다.
```

### SECTION 14 윈도우 서버 보안

#### 1. 윈도우 개요

```
윈도우 서버 보안은 윈도우 운영체제 기반의 서버 시스템을 안전하게 보호하는 것을 말합니다. 이는 서버에 저장된 기밀 정보를 안전하게 보호하고, 불법적인 접근과 공격으로부터 시스템을 보호하며, 데이터 손실을 방지함으로써 비즈니스 연속성을 보장합니다.

보안을 강화하는 가장 일반적인 방법 중 하나는 관리자 암호 생성 정책입니다. 이는 관리자 계정에 대한 강력한 암호 사용을 강제하는 것입니다. 또한, 방화벽 설정도 중요합니다. 외부에서의 공격이나 다른 네트워크로의 침입을 차단하고, 보안 프로그램을 설치해야 합니다.

서버 업데이트와 패치도 매우 중요합니다. 모든 새로운 보안 업데이트를 설치하여 최신 보안 결함 문제를 해결해야 합니다. 그리고 권한 부여 및 액세스 제어 역시 중요한 부분입니다. 파일에 대한 권한 및 액세스 수준을 제어하여 중요한 정보를 무단으로 볼 수 없도록 합니다.

마지막으로, 백업 및 복구 계획도 필요합니다. 재난이 발생했을 경우 데이터를 복원하는 일은 매우 중요합니다. 정기적인 백업 및 데이터 복구 테스트가 이루어져야 합니다.

위의 방법들을 유지 및 강화하면서 서버 시스템에 대한 보안을 유지하면, 중요한 데이터나 시스템에 대한 불법적인 액세스와 공격으로부터 안전하게 보호할 수 있습니다.
```

#### 2. 윈도우 보안

#### 3. 윈도우 서버 보안 설정

```
윈도우 서버의 보안 설정을 강화하는 방법은 다양하며, 이를 위해 다음과 같은 조치들이 필요합니다.

#### 1. 관리자 계정 보호

- 관리자 암호 생성 정책을 통해 복잡하고 안전한 암호를 사용합니다.
- 로컬 관리자 그룹 및 원격 데스크톱 서비스와 같은 중요한 기능에 대한 접근을 최소화합니다.
- 여러 사용자가 동시에 로그인하려는 경우 그룹 정책을 사용하여 로그인 가능 사용자 수를 제한할 수 있습니다.

#### 2. 파일 시스템 권한

- 중요한 데이터 및 파일에 대한 액세스 권한을 신중하게 관리합니다.
- 권한이 필요하지 않은 사용자에게는 엑세스를 제한합니다.
- 세밀한 권한 부여를 위해 그룹 정책을 사용합니다.

#### 3. 방화벽 설정

- 외부에서의 공격 및 침입을 차단하기 위해 방화벽을 설정합니다.
- 필요한 포트만 열어놓고, 그 외의 모든 포트는 차단합니다.
- 내부 네트워크보다 더 높은 신뢰도를 가진 네트워크에는 추가적인 방화벽을 설치해 보호합니다.

#### 4. 보안 소프트웨어

- 백신 및 방화벽과 같은 보안 소프트웨어를 설치하고 최신 업데이트를 유지합니다.
- 다른 서버에는 악성 코드가 전파되지 않도록 입구를 신중하게 관리한다.
- 불필요한 인터넷 연결을 차단하여 세심한 검사와 모니터링을 수행할 충분한 자원과 시간을 제공합니다.

#### 5. 업데이트 및 패치

- 윈도우 서버와 응용 프로그램들은 정기적인 보안 업데이트와 패치를 받아야 합니다.
- 해결된 보안 문제에 대한 정보를 확인하고 해당 문제에 대한 업데이트를 적용해야 합니다.
- 취약한 프로그램인 경우 최신 버전으로 업그레이드하는 것이 좋습니다.

위의 조치들을 적극적으로 수행함으로서, 서버 시스템에 대한 보안 설정을 강화할 수 있습니다. 이러한 조치들은 서버 시스템 내부의 데이터와 기능을 보호하며, 외부 공격으로부터 서버를 안전하게 보호할 수 있습니다.
```

#### 4. Windows 네트워크 서비스

```
Windows 네트워크 서비스는 컴퓨터 네트워크에서 파일 및 프린터 공유, 인터넷 연결 공유 등의 서비스를 제공하는 기능입니다.

Windows 운영 체제는 각각의 네트워크 서비스를 실행하고 관리하기 위해 다양한 도구와 기능을 제공합니다. 예를 들어, "파일 및 프린터 공유" 서비스를 사용하여 로컬 디스크에 저장된 파일과 프린터를 공유할 수 있으며, "인터넷 연결 공유" 서비스를 사용하여 라우터를 통해 인터넷 연결을 공유할 수 있습니다.

Windows 네트워크 서비스는 많은 사용자들이 여러 패치 및 업데이트를 수반하는 공개적인 예시들 중 하나입니다. 이는 네트워크를 공유하는 것이 보안상으로도 위험하다는 증거 일 수 있습니다. Windows 네트워크 서비스는 관련되는 보안 설정 및 정책을 잘 관리함으로써 안전하게 사용할 수 있습니다.
```

### SECTION 15 유닉스/리눅스 서버 보안

#### 1. 유닉스(UNIX)

#### 2. UNIX 기본 사용법

#### 3. UNIX 시스템 관리

#### 4. UNIX 서버 보안

#### 5. 리눅스(Linux)

#### 6. 유닉스/리눅스 서버 취약점 분석·평가

### SECTION 16 서버 보안 관리

#### 1. 서버관리자의 업무

#### 2. 로그 설정과 관리

#### 3. 공개 해킹도구에 대한 이해와 대응

#### 4. 서버보안용 S/W 설치 및 운영

### SECTION 17 각종 시스템 보안위협 및 대응책

#### 1. 버퍼 오버플로우 공격

```
버퍼 오버플로우는 프로그램이 메모리 버퍼를 초과하여 데이터를 쓸 때 발생하는 보안 공격입니다. 이러한 공격은 해커가 악의적인 목적으로 다음과 같은 방법을 사용합니다.

1. 버퍼 오버플로우
해커는 입력 필드에 임의의 긴 값을 입력하여 메모리 버퍼를 넘치게 합니다. 이렇게 하면 다른 정보가 덮어 쓰여질 수 있는 버퍼 상단 영역을 덮어 써서, 원래의 프로그램 흐름을 조작할 수 있습니다.

2. 코드 인젝션
해커는 악성 코드를 입력 필드에 삽입하고, 이를 실행시키기 위해 프로그램의 제어 흐름을 조작합니다. 이 공격 방법을 사용하면, 해커는 시스템을 제어하거나 기밀 정보를 탈취할 수 있게 됩니다.

3. 스택 기반 버퍼 오버플로우
스택 기반 버퍼 오버플로우 공격은 스택 메모리 공간에 대한 참조가 잘못된 경우 발생할 수 있습니다. 이 공격은 스택 메모리 프레임에서 리턴 주소를 조작하고, 해커가 작성한 코드의 주소를 리턴한다. 이렇게 하면 악성 코드가 실행됩니다.

위와 같은 버퍼 오버플로우 공격 방법을 예방하기 위해, 소프트웨어 개발자는 입력 필드에 대한 검증 및 제한을 적용하여 메모리 버퍼 공간 초과를 방지할 수 있습니다. 또한, 안전한 프로그래밍 기술과 보안 설정을 적용하여 해킹 시도로부터 시스템을 보호할 수 있습니다.
```

#### 2. 포맷 스트링 공격

```t
포맷 스트링 공격은 C나 C++같은 언어에서 사용되는 서식 문자열(format string) 처리 관련 취약점입니다. 이 취약점은 사용자의 입력값이 서식 문자열에 직접 삽입되면서 발생합니다.

일반적으로 서식 문자열은 printf(), sprintf(), fprintf() 등의 함수를 사용하여 출력을 포맷팅하기 위해 사용됩니다. 그러나 이러한 함수들은 서식 문자열 인자로 전달된 값을 해석할 때, 보안 검사를 수행하지 않기 때문에 사용자로부터 입력된 문자열이 악의적인 코드인 경우 실행 흐름을 변경하거나 데이터를 유출하는 등의 공격에 이용될 수 있습니다.

예를 들어, 아래와 같은 코드가 있다고 가정합니다.

```

```c
char input[100];
gets(input);
printf(input);
```

```t

위 코드에서 gets() 함수를 통해 입력받은 값이 printf() 함수의 인자로 전달되고 있습니다. 만약 사용자가 "%s" 대신 "%x"와 같은 서식 문자열을 전달한다면 프로그램이 비정상적으로 동작하거나, 시스템 내의 데이터를 읽거나 쓰는 등의 악성코드가 실행될 수 있습니다.

따라서 포맷 스트링 취약점을 방지하기 위해서는 반드시 입력값을 검증하고, 가능하다면 서식 문자열을 직접 구성하지 않고 대안 함수나 라이브러리를 사용하는 것이 좋습니다.
```

#### 3. 레이스 컨디션 공격

```t
레이스 컨디션 공격(Race Condition Attack)은 동시에 여러 개의 스레드나 프로세스에서 같은 자원을 접근하고 수정할 때 발생할 수 있는 보안 취약점입니다. 이러한 취약점은 예기치 않은 결과를 초래할 수 있으며, 해당 공격으로 인해 악의적인 사용자가 안전하지 않은 액세스 권한을 얻어 시스템을 해킹할 수도 있습니다.

예를 들어, 도서관에서 책을 대출하는 상황에서 레이스 컨디션 공격이 일어날 수 있습니다. 무조건적으로 대출 연장을 허용하는 경우, 한 사람이 이미 책을 연장하고자 하는데 동시에 또 다른 사람도 그 책을 연장하고자 하는 경우 둘 중 하나는 실패합니다. 만약 이러한 오류가 일어 나면, 더 많은 사용자들이 같은 책을 대출하거나 연장하려는 경우 이러한 문제가 심화됩니다.

따라서 프로그램에서 레이스 컨디션 공격을 방지하기 위해서는, 공유 자원에 대한 액세스를 제한하고, 안전한 동기화 기술을 사용하여 여러 작업이 동시에 실행되지 않도록 보호해야 합니다. 이를 위해서는, Critical Section이라고 하는 코드 영역에 락을 걸어서 하나의 스레드만 접근할 수 있도록 제어하거나, 세마포어와 같은 동기화 기술을 사용하여 여러 스레드가 자원에 안전하게 액세스할 수 있도록 해야합니다.
```

#### 4. 백도어(back door)

```t
백도어(back door)는 일반적으로 시스템에 의해 비공개로 유지되는 약점이나 보안 설정을 우회할 수 있는 경로를 말합니다. 더 쉽게 말해, 백도어란 권한 없이 접근이 가능한 비밀 통로를 뜻합니다.

이러한 백도어는 대체로 악성 코드나 해커가 설치하거나 서비스 제공자가 의도적으로 설치하는 경우가 많습니다. 백도어는 시스템의 데이터를 탈취하거나 악성 코드를 실행시키고, 불법적인 액세스 권한을 획득하는 등으로 사용될 수 있으므로, 보안 위협으로 간주됩니다.

일부 법적인 상황에서는, 백도어는 구매자 또는 사용자의 동의없이 설치된 경우, 합법적인 그리고 정상적인 권한은 없습니다. 따라서 백도어가 발견되면, 해당 버그나 취약점을 수정하거나, 백도어를 찾아내어 삭제하여 보안 문제를 해결해야 합니다.

요약하면, 백도어는 시스템의 정보 보호를 위해 매우 중요한 역할을 합니다. 따라서 세심한 보안관리와 안전한 보안시스템의 구축은 필요합니다.
```

#### 5. 시스템 자원 고갈 공격(시스템 서비스 거부 공격)

```t
시스템 자원 고갈 공격 또는 시스템 서비스 거부(Denial of Service, DoS) 공격은 일반적으로 네트워크 공격자가 대상 시스템에 의도적으로 액세스하여 시스템 자원을 소모시켜 정상적인 서비스 제공을 방해하는 공격입니다.

이러한 종류의 공격은 시스템의 계산 리소스(CPU), 메모리 공간, 대역폭 등을 차지하거나 사용 중지시키고, 이를 통해 서비스 거부 상황을 유발합니다. 예를 들어, 많은 데이터 패킷을 보내 하나의 시스템에서 처리할 수 없도록 만드는 TCP SYN Flooding 공격이나 DNS Amplification 공격 등이 그 예입니다.

DoS 공격의 목적은 주로 대상 시스템의 가용성을 해치고, 불법적인 이득을 얻기 위한 것입니다. 시스템 자원 고갈 공격은 사이버 범죄 분야에서 가장 평범하면서도 파괴적인 방식 중 하나이며, 대응하기가 쉬운 문제가 아닙니다. 여기서 가장 중요한 것은 사용자 모니터링 및 이상 징후 탐지입니다.

DoS 공격을 방지하기 위해서는, 시스템과 네트워크의 보안 상태를 검사하고 모니터링하는 것이 가장 기본적인 대책으로 적용됩니다. 또한, 방화벽, 컨텐츠 필터링, 인증 및 암호화 프로토콜 등 다양한 기술적 보호 조치를 적용하여 대응할 수 있습니다.
```

#### 6. 리버스 엔지니어링

```t
리버스 엔지니어링(Reverse Engineering)이란 이미 만들어진 제품, 소프트웨어, 하드웨어 등의 내부 동작 원리나 설계 정보를 분석하여 그것을 다시 이용하는 기술입니다. 주로 법적인 목적으로 사용되거나 제품 개발에 유용하게 쓰일 수 있습니다.

소프트웨어 리버스 엔지니어링은 보안 패치, 복잡한 알고리즘 및 시스템 동작을 분석하거나 수정하기 위해 사용됩니다. 반면 하드웨어 리버스 엔지니어링은 제품의 설계와 작동 방법을 이해하고 필요한 경우 연구 및 개선을 위해 사용합니다.

단, 리버스 엔지니어링은 합법성 문제가 매우 중요합니다. 저작권 및 지적재산권을 침해하지 않도록 법적인 규정과 윤리적인 경계를 준수해야 합니다.
```

#### 7. 기타 시스템 보안위협 및 대응책

### SECTION 18 최신 보안 주제들

#### 1. 블록체인(BlockChain)

```t
블록체인(Blockchain)은 분산 원장 기술로, 거래 내역이나 정보를 블록 단위로 기록하고 이를 연결해 하나의 체인으로 만들어 관리하는 기술입니다.

블록체인은 중앙 서버가 없이 전체 네트워크 노드에 분산되어 저장됩니다. 블록 안에는 여러 거래 정보와 이전 블록의 해시값 등이 포함되어 있습니다. 이렇게 블록이 이어진 체인 형태로 데이터가 저장되기 때문에 한 블록이 위조되거나 변경될 경우 이전 블록의 정보도 함께 변경되므로 전체적으로 신뢰성이 유지됩니다.

블록체인의 분산원장 기능은 송금, 금융 거래, 증명서 발행 등 다양한 영역에서 사용될 수 있으며, 블록체인을 기반으로 한 암호화폐(Bitcoin, Ethereum 등)가 대표적인 예시입니다.

하지만 블록체인 기술 자체가 완벽하지 않고 문제점도 존재합니다. 예를 들어 많은 시간과 비용이 필요하다는 점, 확장성 문제, 개인정보 보호 등이 그것입니다. 따라서 블록체인 기술이 발전하면서 이러한 문제들도 해결되어야 합니다.
```

#### 2. 사물인터넷(IoT, Internet of Things)

```t
사물인터넷(IoT, Internet of Things)은 인터넷에 연결된 다양한 사물들이 서로 통신하여 정보를 주고받는 기술입니다. 이 기술을 통해 우리는 스마트 홈 등 생활 전반에 걸친 자동화와 관련된 서비스들을 이용할 수 있습니다.

IoT는 각각의 사물들이 센서와 액추에이터, 네트워크, 컴퓨팅 리소스 등을 가지고 인터넷에 연결됩니다. 이들은 서로 데이터를 교환하고 상호 작용을 할 수 있습니다. IoT는 물리적 모습과 같이 복잡한 여러 상황에 적용 가능하며, 예컨대 자동차나 가전제품 등도 그 예시입니다.

IoT의 장점으로는 건강관리, 에너지 절약, 편의성 증대 등이 있으며, 머신러닝, 빅데이터 분석 등과 결합하여 더 높은 수준의 서비스 제공이 가능해집니다

하지만, 동시에 보안 및 정보유출 문제도 발생할 수 있기 때문에 안정적인 인프라와 보안 체계의 구축이 필요합니다.
```

#### 3. 클라우드 보안

```t
클라우드 보안은 클라우드 서비스를 이용하는 사용자들이 자신의 데이터 및 정보를 안전하게 보호하기 위한 방법과 절차를 말합니다. 클라우드 보안의 중요성은 매우 큽니다. 왜냐하면 개인 정보나 기업 비즈니스 데이터와 같은 중요한 정보가 클라우드에 저장되기 때문입니다.

클라우드 보안을 유지하기 위해서는 다양한 보안 조치가 필요합니다.

1.접근 제어: 민감한 데이터나 정보에 대한 접근 권한을 관리하고, 엄격한 접근제어를 통해 안전하게 유지할 수 있습니다.

2. 데이터 암호화: 클라우드 내부의 데이터를 암호화하여 보호할 수 있으며, 데이터 백업도 꼭 필요합니다.

3. 네트워크 보안: 가상 사설 네트워크(VPN) 등을 사용하여 세션을 암호화하고, DoS 공격으로부터 보호하는 등의 보안조치를 취할 수 있습니다.

4. 취약점 분석: 시스템 내부와 외부에서 발생할 수 있는 모든 취약점을 찾아내고, 그것을 미리 예방하거나 대처해야 합니다.

5. 교육 및 훈련: 사용자나 직원들에게 클라우드 보안의 중요성을 교육하고, 실제 상황에서 대처할 수 있도록 훈련하는 것이 매우 중요합니다.

그 외에도 클라우드 보안은 계속해서 변화하고, 발전해 나가고 있습니다. 따라서 최신 보안 기술과 트랜드를 파악하며 유지보수와 업그레이드가 필요합니다.
```

#### 4. 랜섬웨어(Ransomware)

```t
랜섬웨어(Ransomware)는 해커가 사용자의 컴퓨터나 모바일 기기에 침입하여, 해당 기기나 파일을 암호화하거나 잠금 처리한 후 비트코인 등의 가상 화폐로 금전적 보상을 요구하는 악성 소프트웨어입니다.

랜섬웨어 공격은 전 세계적으로 많은 피해를 일으켰으며, 최근 몇 년 동안 증가세를 보이고 있습니다. 일반적으로, 이메일 첨부파일, 소셜 엔지니어링, 제로데이 취약점 등을 통해 유포됩니다.

랜섬웨어의 종류는 매우 다양합니다. 몇몇은 단순히 파일을 암호화하기도 하고, 다른 것들은 시스템을 깊이 침투하여 관리자 권한을 탈취하거나, 블루스크린을 유발하기도 합니다.

랜섬웨어를 예방하기 위해서는 백업 작업과 같이 데이터를 안전하게 보관하고, 보안 소프트웨어를 설치하며, 업데이트를 지속적으로 수행하는 것이 중요합니다. 또한, 사내 보안 정책을 준수하며, 이메일 및 메신저를 통해 수신하는 파일과 링크를 주의해야 합니다.

만약 랜섬웨어에 감염된 경우에는 급히 전문가들의 도움을 받아 복구해야 합니다. 그러나 미리 예방하는 것이 가장 좋은 방법입니다.
```

#### 5. APT(Advanced Persistent Threat)

```t
APT는 "Advanced Persistent Threat"의 약자로, 높은 수준의 기술과 활동에서 나타나는 지속적인 해킹 공격을 말합니다.

APT를 구성하는 주요 특징으로는 대상에 대한 지속적이고 일관된 관심, 적극적이며 집중적인 탐색 및 정보 수집, 고도의 기술과 전문 지식, 다양하고 정교한 해킹 기술, 악성코드 및 다른 침입 도구와 같은 요소들이 있습니다.

APT의 목적은 주로 기업, 정부기관 등의 중요한 정보를 탈취하거나 파괴하는 것입니다. 이러한 공격은 일반적으로 일반적인 사이버 공격보다 지능화되어 있으며, 여러 단계에서 이루어질 수 있습니다. APT는 매우 위험하며 예방하기가 어려우므로, 보안 전문가들은 지속적인 모니터링과 보안 체제의 강화를 권장합니다.
```

#### 6. 기타 최신 보안주제들

## PART 05 네트워크 보안

### SECTION 19 네트워크 개요

#### 1. 개요

#### 2. OSI 모델과 TCP/IP 프로토콜

### SECTION 20 TCP/IP

```t
OSI 모델은 "Open Systems Interconnection Reference Model"의 약자로, 네트워크 통신에 대한 표준화된 개념적 모델입니다. OSI 모델은 7개의 계층으로 구성되어 있으며, 각 계층은 하위 계층에서 받은 데이터를 가공하고 상위 계층으로 전달합니다.

각 계층은 아래와 같습니다:
- 물리(Physical) 계층
- 데이터 링크(Data Link) 계층
- 네트워크(Network) 계층
- 전송(Transport) 계층
- 세션(Session) 계층
- 표현(Presentation) 계층
- 응용(Application) 계층

TCP/IP 프로토콜은 인터넷에서 널리 사용되는 프로토콜입니다. TCP는 "Transmission Control Protocol"의 약자이며, 신뢰성 있는 데이터 전송을 담당하는 프로토콜입니다. IP는 "Internet Protocol"의 약자이며, 인터넷에서 데이터 패킷의 라우팅을 담당하는 프로토콜입니다.

TCP/IP 프로토콜은 OSI 모델과 다른 점이 있지만, 주요 4개 계층이 일치합니다.
- 네트워크 액세스(Network Access) 계층 (OSI의 물리 및 데이터 링크 계층)
- 인터넷(Internet) 계층 (OSI의 네트워크 계층)
- 전송(Transport) 계층 (OSI의 전송 계층)
- 응용(Application) 계층 (OSI의 세션, 표현 및 응용 계층)

TCP/IP 프로토콜은 OSI 모델보다 간단한 구조를 가지고 있으며, 인터넷에서 데이터를 주고받는 데에 널리 사용됩니다.
```

#### 1. 물리 계층

```t
물리 계층은 OSI 모델의 7개 계층 중 가장 하위에 위치한 계층입니다. 물리 계층은 주로 데이터 통신에서 전기적, 기계적, 물리적인 특성과 상호 연결된 인터페이스와 전송 매체(케이블, 광섬유 등)에 대한 표준을 정의합니다.

물리 계층의 역할은 단순합니다. 데이터를 비트 단위인 0과 1로 변환하고 이진 신호로 변환하여 다른 시스템으로 전송합니다. 이전 계층에서 수신된 프레임, 패킷 또는 세그먼트와 같은 데이터 단위는 이진 코드로 변환되고 케이블 또는 전송 매체를 통해 전송됩니다.

이러한 데이터 전송 방식은 대부분 물리적인 전송 매체에서 발생하는 노이즈와 같은 외부 요소로부터 많은 영향을 받습니다. 따라서 물리 계층은 신호 강도, 송수신 장치의 속도 및 케이블 길이 등과 같은 물리적인 특성을 고려하여 데이터를 안정적으로 전송하도록 보장합니다.

이러한 이유로 물리 계층은 OSI 모델에서 가장 기본적인 계층 중 하나입니다. 데이터 통신의 다른 계층들이 제대로 작동하기 위해서는 물리 계층이 안정적으로 동작해야 합니다.
```

#### 2. 데이터링크 계층

```t
데이터 링크 계층은 OSI 모델의 7개 계층 중 물리 계층 다음으로 위치한 계층입니다. 데이터 링크 계층은 물리적인 전송 매체 상에서 오류 없이 프레임을 안전하게 전송하기 위한 기능을 제공합니다.

데이터 링크 계층은 두 개의 하위 계층을 포함합니다.
- MAC(Media Access Control) 계층: 네트워크 장비 간의 물리적인 주소 지정과 데이터 패킷 우선 순위 결정 등을 담당합니다.
- LLC(Logical Link Control) 계층: 흐름 제어, 오류 검출 및 수정, 논리적인 주소 설정 등을 담당합니다.

데이터 링크 계층의 역할은 크게 세 가지로 나눌 수 있습니다.

1. 프레임 동기화(Synchronization): 프레임은 물리 계층에서 이진 코드로 변환되어 전송됩니다. 데이터 링크 계층은 이진 코드를 구분해서 프레임의 시작과 끝을 인식하고 데이터를 추출하여 상위 계층에 전달합니다.

2. 오류 제어(Error Control): 데이터링크 계층에서는 출력 측에서 전송한 프레임의 에러 검출을 수행하고, 에러가 발생한 경우 에러에 해당하는 프레임을 버리게 됩니다. 또한 재전송 기능도 수행하며, 프레임의 순서를 맞추는 기능도 합니다.

3. 흐름 제어(Flow Control): 가장 일반적인 흐름 제어 방식은 Stop-and-wait과 Sliding Window입니다. Stop-and-Wait 방식에서는 전송 대기 시간이 길어질 수 있으나, 이 방식은 오류가 발생할 경우에만 재전송하므로 검사 복잡성이 감소합니다. Sliding Window 방식은 중복 전송이 가능하나 처리 복잡성이 증가합니다.

따라서 데이터 링크 계층은 상위 계층에서 받아들인 데이터를 프레임으로 나누어 물리 계층으로 보내고, 수신된 프레임을 다시 상위 계층으로 전달합니다. 이 과정에서 프레임 오류 검출과 흐름 제어 같은 기능을 실행하여 안정적인 데이터 전송을 보장합니다.
```

#### 3. 네트워크 계층

```t
네트워크 계층은 OSI (Open Systems Interconnection) 모델에서 3번째 층으로, 데이터의 전송 경로를 설정하고 제어하는 기능을 담당합니다.

이 계층의 주요 기능은 다음과 같습니다.

- 논리 주소 지정(Logical addressing): 목적지와 송신지의 주소를 결정하여 라우터가 패킷을 전송할 경로를 정함
- 라우팅(Routing): 경로를 선택하고 해당 경로에 따라 패킷을 전송
- 흐름 제어(Flow control): 수신자 프로세스의 처리 속도보다 더 많은 데이터가 송신되는 것을 방지하기 위해 전송 데이터의 양을 조절
- 오류 제어(Error control): 패킷 전송 과정에서 발생하는 오류를 검출하고 복구
- 세그멘테이션(Segmentation): 전달된 메시지를 더 작은 단위인 패킷으로 분할하여 전송

네트워크 계층은 인터넷 프로토콜(IP)이 대표적인 예시입니다. IP는 인터넷 상의 모든 컴퓨터나 네트워크 장비가 갖추어야 하는 필수적인 프로토콜입니다.
```

#### 4. 전송 계층

```t
전송 계층은 OSI (Open Systems Interconnection) 모델에서 4번째 계층으로, 호스트 간의 통신을 제어하고 에러 복구 및 흐름 제어를 수행합니다.

이 계층은 데이터 전송에 있어 신뢰성 있는 연결을 구성하기 위한 서비스를 제공하기 때문에, 오류 검출 및 복구, 흐름 제어 그리고 순서화 기능 등이 중요합니다.

전송 계층의 대표적인 프로토콜은 TCP(Transmission Control Protocol)와 UDP(User Datagram Protocol)입니다.

- TCP: 연결형 프로토콜이며, 신뢰성 있는 데이터 전송을 보장합니다. 데이터 분할, 전송 순서화, 흐름제어, 오류 제어 등의 기능을 제공하며, 대부분의 인터넷 애플리케이션에서 사용됩니다.
- UDP: 비연결형 프로토콜이며, 데이터 전송에 대한 보장성이 없기 때문에 속도는 빠르지만, 데이터의 손실 우려가 있습니다. 따라서 음성, 영상 스트리밍과 같은 실시간 데이터 처리에 적합합니다.

전송 계층은 종단 간(end-to-end) 서비스를 제공한다는 점에서, 네트워크 상의 모든 프로토콜들 중 데이터를 보내고 받는 응용 프로그램에 가장 가깝게 위치해 있습니다.
```

#### 5. 응용 계층

```t
응용 계층은 OSI (Open Systems Interconnection) 모델에서 7번째 계층으로, 최종 사용자가 네트워크에 접근하여 데이터를 주고받을 수 있도록 응용 프로그램과 네트워크 서비스를 제공합니다.

이 계층의 역할은 사용자와 직접적으로 상호작용하면서, 일반적인 인터넷 기능들을 제공하는 것입니다. 예를 들면, 이메일, 파일 전송, 웹 브라우징, 동영상 스트리밍 등이 있습니다.

응용 계층은 친숙한 인터페이스와 프로토콜을 제공하여 사용자가 쉽게 네트워크 서비스를 이용할 수 있도록 합니다. 이 계층에서 사용되는 프로토콜은 HTTP, FTP, SMTP, POP3, IMAP 등이 있습니다.

- HTTP: 웹 브라우징에서 사용되는 프로토콜로, 클라이언트와 서버 간에 웹 페이지를 주고 받는 데 사용됩니다.
- FTP: 파일 전송 프로토콜로, 서버에 있는 파일을 클라이언트로 전송하는 데 사용됩니다.
- SMTP: 이메일 발송 프로토콜로, 발신자가 수신자에게 이메일을 보내는 데 사용됩니다.
- POP3: 이메일 수신 프로토콜로, 이메일 클라이언트에서 메일 서버로부터 이메일을 가져오는 데 사용됩니다.
- IMAP: 이메일 수신 프로토콜로, 이메일 클라이언트가 메일 서버에 남겨져 있는 이메일을 관리할 수 있도록 해줍니다.

응용 계층은 OSI 모델에서 가장 상위에 있기 때문에 네트워크 아래의 상위 6개 계층 모두를 활용하여 데이터 전송을 구현합니다.
```

### SECTION 21 라우팅

#### 1. 라우팅 개요

- 라우팅은 패킷을 전송하기 위해 송신자측에서 목적지까지의 경로를 정하고, 정해진 경로를 따라 패킷을 전달하는 일련의 과정
- 라우터는 라우팅의 기능을 수행하며 네트워크 계층 주소를 참조하여 가능한 한 여러 경로 중에서 최손의 경로를 결정
- 라우팅 알고리즘은 관리자가 직접 라우팅 테이블을 설정하는 정적 라우팅 알고리즘과 네트워크 환경 변화에 능동적으로 대처 가능한 동적 라우팅 알고리즘으로 구분
- AS(자율시스템) 내에 운영되는 라우팅 프로토콜을 IGP라고 하며, AS 간에 라우팅 정보를 교환하기 위한 프로토콜을 EGP라고 함.

```t
네트워크 계층의 중요한 기능 중 하나인 라우팅은 여러 경로를 통해 목적지로 데이터 패킷을 전송하는 과정입니다.

라우팅 프로토콜은 네트워크 상에서 라우터들 간에 서로 정보를 교환하면서 최적의 경로를 설정합니다. 이 때 사용되는 정보는 대부분 라우터 간의 거리, 링크의 속도, 혼잡도 등입니다.

라우팅 기법에는 다음과 같은 것들이 있습니다.

* 스태틱 라우팅(Static routing): 수동으로 경로를 구성하여 설정하는 방식으로, 작고 단순한 네트워크에서 주로 사용됩니다.
* 동적 라우팅(Dynamic routing): 라우터가 네트워크에서 다른 라우터들과 정보를 주고받아 경로를 동적으로 조정하는 방식으로, 대규모 네트워크에서 사용됩니다.

라우팅은 IP(Internet Protocol)의 핵심 개념 중 하나이며, 인터넷에서 수많은 데이터 패킷이 목적지에 정확하게 전달할 수 있는 원인 중 하나입니다.
```

#### 2. 유니캐스트 라우팅

```t
유니캐스트 라우팅(Unicast routing)은 하나의 송신자와 하나의 수신자 사이에 통신하는 방식으로, 데이터 패킷을 전송할 때 목적지 주소를 지정하여 보내는 방식입니다. 이는 가장 일반적인 라우팅 방식 중 하나입니다.

유니캐스트 라우팅에는 다음과 같은 라우팅 프로토콜이 있습니다.

- RIP(Routing Information Protocol): 거리 벡터 알고리즘을 기반으로 하는 프로토콜이며, 전체 네트워크 내에서 경로 최대 홉 수를 15로 제한합니다.
- OSPF(Open Shortest Path First): 링크 상태 프로토콜(LSP)을 기반으로 한 프로토콜입니다. LSP는 인접한 라우터 간에 링크 정보를 공유하는 메시지입니다. OSPF는 네트워크 규모가 커질수록 유용합니다.
- BGP(Border Gateway Protocol): 대규모 ISP(Internet Service Provider)에서 사용되는 프로토콜로, 게이트웨이 라우터들 간의 정보 교환을 기반으로 합니다.

유니캐스트 라우팅은 비교적 단순한 라우팅 방식으로, 모든 네트워크에서 사용 가능합니다. 하지만 대규모 네트워크나 인터넷을 다룰 때는 더 많은 정보를 처리할 수 있는 OSPF와 BGP와 같은 복잡한 라우팅 프로토콜이 필요합니다.
```

##### (1) 라우팅 알고리즘

```t
라우팅 알고리즘은 패킷이 송신자로부터 목적지까지 가는 경로를 결정하는 방식을 말합니다.

라우팅 알고리즘은 크게 두 가지 유형이 있습니다. 첫 번째 유형은 정적 라우팅 알고리즘이며, 사전에 수동으로 경로를 구성하는 것입니다. 이는 네트워크가 작고 안정된 경우에 사용할 수 있습니다.

두 번째 유형은 동적 라우팅 알고리즘이며, 경로를 자동으로 조정하며 네트워크의 특성을 고려해 최적의 경로를 찾습니다. 대표적인 동적 라우팅 프로토콜로 OSPF, BGP 등이 있습니다.

라우팅 알고리즘의 작동 방식은 크게 다음과 같은 단계로 이루어집니다.
1. 패킷의 목적지 IP 주소를 확인합니다.
2. 해당 목적지까지의 경로를 찾기 위해 라우팅 테이블을 검색합니다.
3. 라우팅 테이블에 목적지 IP 주소와 일치하는 라우팅 정보가 없으면, 라우팅 프로토콜을 사용하여 새로운 경로를 찾습니다.
4. 새로운 경로를 라우팅 테이블에 추가하고, 다시 패킷을 전송합니다.

라우팅 알고리즘은 서로 다른 프로토콜, 매트릭스, 보안 등의 요소를 고려하여 최적의 경로를 결정합니다. 따라서 이를 잘 이해하고 적절하게 설정하는 것이 중요합니다.
```

##### (2) 유니캐스트 라우팅 알고리즘

###### RIP (Routing Information Protocol)

```t
RIP (Routing Information Protocol)는 거리 벡터 알고리즘을 사용하는 동적 라우팅 프로토콜 중 하나입니다. RIP는 네트워크에서 라우터 간 경로 정보를 교환하고 최적의 경로를 찾아 패킷 전송에 이용됩니다.

RIP는 홉 수 (hop count)를 측정하여 가장 경로가 짧은 경로를 찾습니다. 홉 수란 패킷이 목적지까지 도달하기 위해 거치는 라우터의 수를 의미합니다. RIP는 15홉 이상일 경우에는 경로로 인정하지 않습니다. 이로 인해 RIP는 대규모 네트워크나 멀리 떨어진 통신망에서의 사용이 적합하지 않을 수 있습니다.

RIP에서 라우터는 주기적으로 자신의 라우팅 테이블을 링크-스테이트 패킷으로 브로드캐스트합니다. 이를 통해 인접한 라우터는 상대방의 라우팅 테이블을 받아들이고 자신의 라우팅 테이블과 비교함으로써 최적의 경로를 찾아내게 됩니다. 이때 라우터 간 경로를 교환할 때 UDP 프로토콜을 사용합니다.

RIP의 장점은 구성이 쉽고 간단한 구현을 통해 주요 네트워크 프로토콜에 대한 지원을 제공합니다. 또한, RIP는 일부 라우터가 고장 날 경우 라우팅 테이블을 자동으로 업데이트하여 패킷 전송이 가능하도록 합니다.

하지만 RIP는 홉 수에 기반한 경로 측정 방식 때문에 대규모 네트워크에서는 사용이 어렵습니다. 또한 RIP는 업데이트 주기가 빈번하다는 단점이 있습니다. 그러므로 보다 복잡하면서 성능이 좋은 다른 동적 라우팅 프로토콜들이 개발되었습니다.
```

###### RIP2

```t
RIP2(Routing Information Protocol version 2)는 RIP (Routing Information Protocol)의 개선된 버전입니다. RIP2는 거리 벡터 알고리즘을 기반으로 하며, IPv4 및 IPv6 프로토콜 모두를 지원합니다.

RIP2는 RIPv1과 달리 클래스 없는 IP주소 즉, 서브넷 마스크를 사용해 CIDR(Classless Inter-Domain Routing)을 지원합니다. 이렇게 함으로써 RIP2를 사용하는 네트워크에서 더 많은 IP 주소 연결이 가능해집니다.

RIP2에서는 구성된 모든 인터페이스에 대한 매트릭 값을 보낼 수 있습니다. 이것은 다양한 인터페이스 속도와 대역폭 설정이 가능하게 되어 더 가용성이 좋아지고 긴 처리 지연 시간을 줄여줍니다. RIP2에서는 Auto Summarization(자동 요약) 기능을 지원하여 classless IP 주소를 사용할 때 라우팅 테이블을 요약함으로써 라우터 메모리 사용량을 절감시킬 수 있습니다.

RIP2는 보안 기능을 추가했습니다. 트래픽을 인증하기 위해 Plain Text Password를 사용할 수 있으며 같은 기능을 강화한 Authenticated RIP(ARIP)도 있다.

하지만 RIP2 역시 최대 홉 수 제한이 15로 유지됩니다. 라우팅 정보 교환 시간이 많이 걸리며, 빈번한 업데이트는 많은 대역폭을 사용할 수 있기 때문에 대규모 네트워크에서 적합하지 않을 수 있습니다.

요약하자면, RIP2는 RIPv1보다 많은 기능과 보안 기능을 갖춘 개선된 버전입니다. 하지만 네트워크 규모가 커질수록 성능 문제가 발생할 수 있으므로 대규모 네트워크에서는 다른 동적 라우팅 프로토콜을 고려해야합니다.
```

###### IGRP(interior Gateway Routing Protocol)

```t
IGRP(Interior Gateway Routing Protocol)는 거리 벡터 알고리즘을 사용하는 동적 라우팅 프로토콜 중 하나입니다. Cisco Systems에서 개발하였으며, TCP/IP 네트워크에서 내부 게이트웨이 프로토콜로 사용됩니다.

IGRP는 더 많은 경로 정보를 갖고 있어 RIP보다 대규모 네트워크에서 좋은 성능을 보여줍니다. 이러한 특성 때문에 IGRP는 일반적으로 중간 규모의 기업용 네트워크에서 사용됩니다.

IGRP는 네트워크 토폴로지 상의 최단 경로 및 대역폭, 지연 시간, 신뢰성 등 여러 가지 요소를 고려하여 최적의 경로를 찾습니다. 이것은 다양한 유형의 네트워크에 적응하도록 설계되었습니다.

IGRP에서 라우터는 주기적으로 자신의 라우팅 테이블을 업데이트합니다. 라우터 간에는 매 90초마다 라우팅 업데이트 메시지가 교환되며, 이 메시지에는 현재 네트워크 상태에 대한 정보가 포함됩니다. 이렇게 IGRP는 단점인 불필요한 업데이트를 최소화 하면서 최적의 경로를 계산하며, RIP보다 효율적으로 작동합니다.

그러나 IGRP는 Cisco Systems에서 독점적으로 개발된 프로토콜이므로 다른 업체의 라우터와 호환되지 않을 수 있습니다. 또한 RIP와 비교하여 설정이 복잡하고 구성 및 유지보수가 어려울 수 있습니다.
```

###### EIGRP(Enhanced Interior Gateway Routing Protocol)

```t
먼저, EIGRP(Enhanced Interior Gateway Routing Protocol)은 Cisco Systems에서 개발된 고급 라우팅 프로토콜입니다. 이는 다이나믹 라우팅 프로토콜로, 네트워크의 경로를 자동으로 선택하고 업데이트합니다.

EIGRP는 링크 상태 라우팅(LSR) 프로토콜을 사용하여 라우터 간에 네트워크 정보를 교환합니다. 이를 통해 라우터는 네트워크의 변경 사항을 적극적으로 감지하고 반영할 수 있으며, 다른 라우팅 프로토콜보다 더욱 빠르게 수렴됩니다.

EIGRP는 기본적으로 IP 패킷의 단편화 및 조립, 비용 기반 라우팅, 경로 복구 등의 기능을 제공하며, CPU와 메모리 사용량이 낮아서 대규모 네트워크에서도 잘 작동합니다.

또한, EIGRP는 다른 라우팅 프로토콜과 함께 사용될 수 있으며, OSPF(Open Shortest Path First), BGP(Border Gateway Protocol), RIP(Routing Information Protocol) 등과 같은 다른 라우팅 프로토콜과 호환됩니다.

이러한 이유로 EIGRP는 대규모 기업 네트워크에서 많이 사용되며, 안정성과 확장성에서 큰 이점을 제공합니다.
```

```
LSR(Link State Routing)은 네트워크의 각 노드나 링크의 상태 정보를 수집하여, 전체 네트워크의 현재 상태를 정확하게 파악하는 라우팅 프로토콜입니다.

LSR 방식에서는, 라우터들이 서로 자신의 연결된 인터페이스와 해당 링크에 대한 상태 정보를 주기적으로 교환하여 네트워크의 현재 상태를 인지합니다. 이 정보를 바탕으로 각 라우터는 최적의 경로를 계산하고 다른 라우터들에게 전달합니다. 이렇게 각 라우터가 인근에 있는 라우터들을 알고 있는 것으로부터 출발하여, 모든 라우터가 전체 네트워크 상태를 인지할 수 있게 됩니다.

LSR 방식은 Dijkstra's Shortest Path First 알고리즘을 사용하며, 복잡한 라우팅 테이블 계산을 효율적으로 처리할 수 있습니다. 또한, 상태 정보의 정확도가 높기 때문에 확장성이 좋아 대규모 네트워크에서도 잘 작동합니다.

대표적인 LSR 방식의 라우팅 프로토콜로 OSPF(Open Shortest Path First)가 있으며, BGP(Border Gateway Protocol) 등과 함께 다양한 라우팅 프로토콜과 함께 사용됩니다.
```

###### OSPF(Open Shortest Path First)

- 개방 최단 경로 우선(OSPF)는 RIP과 같은 인트라 도메인 라우팅 프로토콜이다. 하지만 OSPF는 링크-상태 라우팅 프로토콜을 기반으로 한다. OSPF는 개방형 프로토콜로 사양이 공개되어 있다.
- 네트워크에 변화가 생겼을 경우에만 전체 네트워크에 플러딩 과정을 수행함으로써 라우팅 정보를 신속하게 갱신하여 수렴시간과 라우팅 트래픽의 양을 줄였다.
  - 플러딩(flooding): 갱신정보를 인접 라우터로 전송하고, 인접 라우터는 다시 자신의 인접 라우터로 갱신정보를 즉시 전달하여 갱신정보가 네트워크 전역으로 신속하게 전달되는 과정
- 최적경로 계산을 위해 Dijkstra's 알고리즘이라는 링크 상태 알고리즘을 이용한다.
- OSPF는 보안을 ㅜ이해 인증을 지원하고, 세 가지 IP주소 형태인 클래스 단위, 서브넷 단위, 클래스 비사용 주소지정(CIDR)을 지원한다. 매우 큰 AS에서 OSPF를 사용할 때는 라우터 그룹으로 묶어 계층 토폴로지를 만들 수 있다.

###### 거리 벡터와 링크 상태 라우팅 프로토콜 비교

- 거리벡터 라우팅 프로토콜
  - 인접한 이웃으로부터 망 정보를 수집
  - 비용은 이웃 라우터와의 거리 비용을 더해서 구함
  - 주기적인 라우팅 정보 교환
  - 느린 수렴시간
  - 모든 라우팅 테이블 값을 이웃에게 전달
  - 브로드캐스트 방식으로 이웃에게 라우팅 광고
- 링크 상태 라우팅 프로토콜
  - 모든 라우터로부터 망 정보를 수집
  - 최단거리 알고리즘으로 모든 라우터에 대한 비용을 직접 계산
  - 링크 상태 변화 시만 라우팅 정보 교환
  - 빠른 수렴시간
  - 자신에게 직접 연결된 망 정보만 전달
  - 멀티 캐스트 방식으로 라우팅 광고

###### OSPF의 계층 구조

- 큰 네트워크를 잘 제어하고 관리할 수 있도록 OSPF에서는 큰 AS가 계층 구조를 가질 수 있다. 이 계층 구조에서는 연결된 라우터와 네트워크를 영역(Area)으로 묶고, 영역은 논리적 백본(backbone)을 사용하여 연결된다.
- 이런 영역은 큰 AS 내에 있는 작은 AS와 비슷하게 행동한다. 따라서 기관에서 큰 네트워크 트래픽을 관리하기 위해 AS를 관리하는 것처럼 영역 내에서 지역적인 제어가 가능하다.
- 라우터의 브로드 캐스팅은 영역 내로 제한되어 있어 영역 외부로 라우팅 정보 패킷이 전달되지 않는다. 영역 간의 정보전달은 오직 영역 경계 라우터(Area Border Router)를 통해서만 수행된다.

###### BGP4(Border Gateway Protocol version 4)

- 경계 게이트웨이 프로토콜 버전4(BGP4)는 현재 인터넷에서 사용하고 있는 유일한 인터 도메인 라우팅 프로토콜이다.
- BGP4는 경로 벡터 알고리즘(Path Vector Algorithm)을 기반으로 하고 있지만, 인터넷에서 네트워크의 접근성에 대한 정보를 제공하기에 알맞다.
- RIP와 같이 거리벡터에 기초한 알고리즘이지만 패스 벡터 알고리즘에서는 홉수 대신 AS 번호를 매트릭으로 사용한다.

#### 3. 라우터 보안

### SECTION 22 네트워크 장비의 이해

#### 1. 네트워크 장비의 이해

- 랜카드
- 허브(Hub)
  - 물리 계층에서만 동작하는 장치
- 브리지(Bridge)
  - 브리지는 리피터와 달리 패킷 프레임에 대한 인지능력이 있고 OSI의 데이터링크 계층인 MAC(Media Access Control)에서 동작하며, 둘 또는 그 이상의 네트워크를 상호 연결하는데 사용한다.
- 스위치 (Switch)
  - 스위치는 리피터의 기능과 브리지의 기능을 결합한다. 스위치는 리피터처럼 정기적 신호를 증폭하며, 브리지의 내장 회로와 지능을 가진다.
  - 종류 (OSI ckawhahepfdp rlchgks qnsfb)
    - L2 스위치
    - L3 스위치
    - L4 스위치
    - L7 스위치
  - L4 스위치와 L7 스위치의 차이점
    - L4: TCP/UDP 포트 정보를 분석해 해당 패킷이 현재 사용하는 서비스 종류(HTTP, FTP, 텔넷, SMTP, POP3, SSL 등) 별로 패킷을 처리한다.
    - L7: 트래픽의 내용(e-mail의 문자열, HTTP URL, FTP 파일 및 제목 등) 패턴 등을 분석해 패킷을 처리한다
  - 종류 (스위칭 방법에 따른 분류)
    - Store-and-Forward 방식
    - Cut-Through 방식
    - Fragment-Free 방식
  - 라우터 (Router)
    - 3계층 장비로, 물리, 데이터링크, 네트워크 계층에서 동작한다
  - 게이트웨이 (Gateway)
    - OSI 참조모델의 모든 계층을 포함하여 동작하는 네트워크 장비로서, 두 개의 완전히 다른 네트워크 사이의 데이터 형식을 변환하는 기능을 수행

#### 2. VLAN의 구성 및 관리

- 가상 근거리 네트워크 (VLAN, Virtual Local Area Network)를 물리적인 선이 아닌 소프트웨어에 의해 구성한 근거리 네트워크
- 스위치에서 지원하는 기능

### SECTION 23 무선통신 보안

#### 1. 무선통신

##### (1) 무선 네트워크 유형과 무선랜

###### 무선 네트워크 유형

- WPAN: 단거리 Ad Hoc 방식 또는 Peer to Peer 방식
- WLAN: 우선랜의 확장 개념 또는 유선 랜의 설치가 어려운 지역으로의 네트워크 제공
- WMAN: 대도시와 같은 넓은 지역을 대상으로 높은 전송속도를 제공

###### 무선 네트워크 보안 위협의 주요 요소

- 채널(Channel): 무선 네트워크는 일반적으로 브로드캐스팅 통신을 하게 되는데, 이 경우 유선 네트워크보다 도청이나 재밍에 훨씬 취약하다.
- 이동성(Mobility): 실제로 사용하는 무선 장치는 유선 장치보다 휴대가 간편하고 이동이 수월하다. 이런 이동성 때문에 여러 가지 위협이 생긴다.
- 자원(Resource): 스마트폰이나 태블릿 같은 일부 무선 장치는 정교한 운영체제를 가지고 있는데, 메모리와 프로세싱 자원이 제한적이다. 그래서 서비스 거부 공격이나 악성 소프트웨어 위협에 대처하기가 쉽지 않다.
- 접근성(Accessibility): 센서나 로봇 같은 일 부 무선 장치는 직접 관리가 어려운 원격지에 있거나 혹독한 환경에 있다. 이 경우 물리적 공격에 매우 취약해질 수 있다.

###### 무선랜의 특징

- 감쇠
- 간섭
- 다중경로 전달
- 오류

###### 무선랜 접근 제어

##### (2) 무선 표준

###### 무선랜 기술 표준

- IEEE 802.11b
- IEEE 802.11a
- IEEE 802.11g
- IEEE 802.11i
- IEEE 802.11h

##### (3) 무선랜 주요 구성요소

- 무선 AP (Access Point)
- 무선 브리지

##### (4) 다양한 무선통신 기술

###### 블루투스 (Bluetooth)

- 구조
  - 피코넷(piconet)
  - 스캐터넷(scatternet)
- 보안 취약점
  - 블루프린팅(blueprinting): 블루투스 공격 장치의 검색 활동을 의미
  - 블루스나핑(bluesnarㄹing): 블루투스의 취약점을 이용하여 장비의 임의 파일에 접근하는 공격
  - 블루버깅(bluebugging): 블루투스 장비 간의 취약한 연결 관리를 악용하는 공격
  - 블루재킹(bluejacking): 블루투스를 이용해 스팸처럼 명함을 익명으로 퍼트리는 것

#### 2. 무선랜 보안

##### (1) 무선랜 보안 취약점 분석

###### 무선랜의 물리적 취약점

###### 무선랜의 기술적 취약점

- 도청
- 서비스 거부(DoS)
- 불법 AP (Rogue AP)
- 무선 암호화 방식
  - WEP(Wired Equivalent Privacy)
  - WPA/WPA2
- 비인가 접근
  - SSID 노출
  - MAC 주소 노출

###### 무선랜의 관리적 취약점

- 무선랜 장비 관리 미흡
- 무선랜 사용자의 보안의식 결여
- 전파관리 미흡

##### (2) 무선랜 인증 기술

###### SSID 설정과 폐쇄시스템 운영

###### MAC 주소 인증

###### WEP 인증 메커니즘

###### EAP 인증 메커니즘

##### (3) 무선랜 암호화 기술

###### WEP(Wired Equivalent Privacy)

- 무선랜용 기본 암호화 방식인 WEP은 전송되는 무선 LAN에 연결된 무선 AP와 무선 단말기 간에 주고받는 무선 전송데이터를 2개의 장비가 약속한 공유 비밀키와 임의로 선택되는 IV값을 조합한 64비트 혹은 128비트의 키를 이용해 전송데이터를 암호화함으로써 보안을 강화하는 방식
- WEP는 데이터 암호화뿐만 아니라, 공유키를 이용한 사용자 인증 기능도 제공한다. WEP는 서로 같은 공유키를 갖는 사람을 정상 사용자로 인증하는 방식을 채택하고 있다.

###### TKIP(Temporal Key Integrity Protocol)

- TKIP의 목적은 WEP의 강도를 향상시키거나 하드웨어 교체 없이 WEP를 완전히 대체하는 것이었다.

###### CCMP(Counter mode with CBC-MAC Protocol)

##### (4) 무선랜 인증 및 암호화 복합 기술

###### WPA와 WPA2

- WPA
  - WI-FI에서 정의한 무선랜 보안 규격으로 802.11i 보안 규격의 일부 기능을 수용하여 만든 표준 규격이다. 현재 사용되고 있는 하드웨어의 변경 없이 소프트웨어의 업그레이드를 통해 지원 가능하다.

###### WPA-PSK(Wi-Fi Protected Access Pre-Shared Key)

###### 802.1x/EAP(Extensible Authentication Protocol) 보안

#### 3. WAP(Wireless Application Protocol)

##### (1) WAP(무선 응용 프로토콜) 개요

- 무선 응용 프로토콜(WAP, Wireless Application Protocol)은 WAP 포럼에서 개발한 통합된 표준이다. 웹과 같은 정보 서비스에 접근하기 위해 모바일 폰과 페이저(비퍼), PDA 같은 장비에서 이 표준을 사용한다.
- WAP은 모든 기존 무선 네트워크 기술(예를 들어 GSM, CDMA, TDMA) 및 IP, XML, HTML, HTTP 등의 인터넷 기술과 가능한 한 호환해서 사용할 수 있게 설계하였다. WAP는 보안 기능도 포함하고 있다.
- WAP 규격
  - WWW 프로그래밍 모델에 기반한 프로그래밍 모델
  - XML과 무선 마크업 언어 (WML, Wireless Markup Language)
  - 모바일 무선 단말기에 적합한 소형 브라우저의 규격
  - 경량 통신의 프로토콜 스택
  - 무선 전화 응용(WTA, Wireless Telephony Application)을 위한 프레임워크

##### (2) WTLS(무선 전송 계층 보안)

- WTLS은 모바일 장비(클라이언트)와 WAP 게이트웨이 간의 보안 서비스를 제공한다. WTLS는 TLS 프로토콜에 기반
- 종단-대-종단 보안을 제공하기 위해서 클라이언트와 게이트웨이 사이에서는 WTLS를 사용하고, 게이트웨이와 목적지 서버 사이에서는 TLS를 사용한다. WAP 시스템은 WAP 게이트웨이 내부에서 WTLS와 TLS 사이의 변환을 담당

##### (3) WAP(종단-대-종단 보안)

#### 4. 디바이스 인증기술(기기 인증)

#### 5. RFID

#### 6. 모바일 보안

##### (2) BYOD 보안 기술

- MDM(Mobile Device Management)
- 컨테이너화(Containerization)
- 모바일 가상화(Hypervisors)
- MAM(Mobile Application Management)
- NAC(Network Access Control)

### SECTION 24 네트워크 관리

#### 1. 네트워크 관리

- 네트워크 5대 관리 기능
  - 계정 관리
  - 구성 관리
  - 성능 관리
  - 장애 관리
  - 보안 관리

#### 2. SNMP

- SNMP(Simple Network Manangement Protocol)는 관리자와 에이전트의 개념을 사용한다. 즉, 보통 호스트인 관리자는 보통 라우터나 서버인 에이전트의 집단을 제어하고 감시한다.

##### 관리 구성요소

- SNMP는 관리 작업을 수행하기 위해 다른 두 가지 프로토콜, 즉 SMI(Structure of Management Information)와 MIB(Management Information Base)를 사용한다. 달리 말하면 인터넷에서의 관리는 SMI와 MIB 그리고 SNMP의 협동 작업이다.

#### 3. 원격 접속 서비스

##### 원격 접속 프로토콜

- TELNET
- Rlogin
- SSH(Secure Shell)

### SECTION 25 네트워크 기반 프로그램 활용

#### 1. 네트워크기반 프로그램 활용

##### 연결테스트 (ping)

- ping 명령은 인터넷으로 접속하려는 원격 호스트가 정상적으로 운영되고 있는지를 확인하는 진단 목적으로 사용한다.
- ping 명령은 ICMP를 이용하는 유틸리티이다.
- ping 명령으로 접속대상 시스템의 접근성을 진단하는 것 외에도 네트워크 속도를 측정할 수 있다. 그리고 도메인 명을 이용하여 접속대상 시스템의 IP 주소를 알아낼 때도 효과적이다.

##### 경로추적(traceroute)

##### 네트워크 인터페이스 진단(netstat)

- netstat 명령은 UNIX 시스템의 TCP/IP 프로토콜 진단 시 다양한 용도로 사용한다. 네트워크 인터페이스(LAN 카드)에 대한 성능 정보, 시스템의 라우팅 정보, 소켓 사용 정보 등 지정 옵션에 따라서 네트워크 정보를 제공한다.

##### 라우팅 설정(route)

- route 명령을 사용하여 라우팅 테이블에 라우팅 경로를 추가하거나 삭제한다.

##### 네트워크 패킷/로그 분석(tcpdump)

- tcpdump는 네트워크 인터페이스를 거치는 패킷의 내용을 출력해주는 프로그램

##### 네트워크 인터페이스 설정(ifconfig)

##### 윈도우 ipconfig 유틸리티

### SECTION 26 네트워크 기반 공격의 이해

#### 1. 네트워크 기반 위협

#### 2. 네트워크 기반 보안 위협 및 대응책

##### (1) 서비스 거부 공격(DOS; Denial of Service)

- TCP SYN Flooding Attack

  - TCP 연결 설정 과정 중에 3-Way Handshaking 과정에서 Half-Open 연결 시도가 가능하다는 취약점을 이용한 공격으로 공격대상 시스템은 외부로부터 접속 요청을 더 이상 받아들일 수가 없게 되어 정상적인 서비스를 제공할 수 없게 된다.
  - 즉, 공격자가 다수의 syn 신호를 공격 대상자에게 전송하면 공격 대상자는 syn/ack 신호를 공격자에게 전달하게 되는데 이 때 공격자가 ack 신호를 반송하지 않으면 공격대상자의 시스템은 일정 시간동안 신호를 기다리게 된다.
  - 이 공격은 윈도우 시스템뿐만 아니라 인터넷에 연결되어 TCP 기반의 서비스를 제공하는 모든 시스템에 피해를 줄 수 있다.

- SMURF Attack
- Flooding Attack
  - ICMP Flood
  - UDP Flood
- Land Attack
- Ping of Death
- Teardrop Attack
- Inconsistent Fragmentation 공격
  - Bonk
    - 패킷을 프래그먼트하여 전송할 때, 패킷을 조작하여 결과적으로 공격대상자의 시스템 부하를 증가시키는 공격
    - 처음 패킷을 1번으로 보낸 후, 다음 패킷을 보낼 때 순서번호를 모두 1번으로 조작하여 전송하는 DoS 공격
  - Boink
    - Bonk를 수정한 DoS 공격도구로, 처음 패킷을 1번으로 보낸 후 다음 패킷을 100번, 다음 패킷을 200번 등 정상적으로 보내다가 20번째 패킷을 2002, 201번째 패킷을 100, 22번째 패킷을 다시 2002 등으로 중간에 패킷 시퀀스 번호를 비정상적으로 상태로 보내는 공격 기술

##### (2) DDoS 공격

###### 공격 대응 절차

- 1단계; 공격의 인지
- 2단계; DDoS 공격 유형 파악
  - 패킷 덤프(Packet Dump)를 이용한 유입 트래픽 확보
  - 확보된 트래픽 분석(Analysis)
  - 시나리오 기반(Scenario Drawn)의 공격유형 파악
  - 웹서버 접속 로그(WebServer Access Log)
- 3단계; 공격유형에 따른 차단 정책 정의 및 대응
- 4단계; 공격 대응 후, 사후조치

###### DNS 싱크홀(DNS Sinkhole)

- 악성 봇을 조종하는 조종자를 탐지하고, 감염된 개인용 컴퓨터(PC)와 조종자 간의 접속을 차단해 2차 피해를 예방하기 위한 시스템
- DDoS 공격 차단 방법의 하나로 감염된 PC에서 특정 주소로 연결을 원할 때 실제 해당 주소로 데이터가 전송되지 않고 싱크홀 네트워크가 대신 응답하여 패킷이 외부로 전달되지 않도록 처리한다. 이방법을 DNS에 적용한 것이 DNS 싱크홀.
- 한국인터넷진흥원에서 국내 주요 ISP업체 및 가입기관과의 협력을 통해 DNS 싱크홀을 운영하고 있다.

###### DDoS 공격의 사례

- 트리누 (Trinoo) 공격
- TFN (Tribed Flood Network) 공격
- Stacheldraht 공격
- TFN2K 공격

###### 최신 DDoS 공격유형 설명

- UDP/ICMP Traffic Flooding 공격
- TCP Traffic Flooding 공격
- IP Flooding 공격
- HTTP Traffic Flooding 공격
- HTTP Header/Option Spoofing Flooding 공격

###### 분산 반사 서비스 거부 공격(DRDoS; Distributed Reflection Denial of Service)

##### (3) 네트워크 스캐닝

###### 사이버 공격을 위한 준비활동

- 사이버 공격을 위한 정보 수집은 풋프린팅, 스캐닝, 목록화의 3단계 과정을 거친다.
- 풋프린팅은 신문, 게시판 혹은 네트워크 검색, 포털 검색 등의 방법을 통해 공격 대상의 IP블록, DNS/Mail 서버 등의 정보를 수집하는 초기 과정을 말한다.
- 스캐닝은 핑(Ping), 포트 스캔(Port Scan), 운영체제 확인 드으이 방법으로 시스템 종류, IP 주소, 서비스 등을 알아내어 보다 세부적인 정보를 수집하는 과정을 말한다.
- 목록화는 앞선 풋프린팅, 스캐닝 방법을 통해서 수집된 정보를 토대로 라우팅 테이블, SNMP 정보 등 좀더 실용적인 정보를 수집하여 시스템 취약점 분석 및 공격방법 결정을 위한 지표를 작성하는 과정을 말한다.

##### (4) 스니핑(Sniffing)

- 네트워크 트래픽을 도청(eavesdropping)하는 과정
- TCP/IP 프로토콜을 이용한 통신에서는 통신매체를 통과하는 패킷이 암호화가 되지 않은 상태이므로 이 패킷을 도청하여 메시지 내용을 볼 수 있다.

##### 스니핑의 종류

###### 허브 환경에서의 스니핑

###### 스위치 환경에서의 스니핑

- 스위치 재밍(Switch Jamming, MAC Address Flooding, MACOF(MAC OverFlow) 공격)
  - 스위치의 MAC Address Table 버퍼를 오버플로우시켜서 스위치가 허브처럼 동작하게 강제적으로 만드는 기법
  - 스위치는 Fail Open 정책, 즉 실패 시에 모두 허용해주는 정책을 따르는 장비이므로 문제가 발생하면 Hub처럼 연결된 모든 노드에게 패킷을 전송한다.
  - MAC Address Table을 채우기 위해 MAC 주소를 계속 변경하면서 ARP Reply 패킷을 지속적으로 전송하는 방식으로 공격한다.
- ARP 스푸핑(Spoofing)
  - 공격자가 특정 호스트의 MAC 주소를 자신의 MAC 주소로 위조한 ARP Reply 패킷을 만들어 희생자에게 지속적으로 전송하면 희생자의 ARP Cache에 특정 호스트의 MAC 정보가 공격자의 MAC정보로 변경된다. 이를 통해 희상자에게서 특정 호스트로 나가는 패킷을 공격자가 스니핑하는 기법이다.
- ARP 리다이렉트(Redirect)
  - 공격자가 자신이 라우터인 것처럼 MAC 주소를 위조하여 ARP Reply 패킷을 해당 네트워크에 broadcast 한다. 이를 통해 해당 로컬 네트워크의 모든 호스트와 라우터 사이의 트래픽을 스니핑하고, IP Forward 기능을 통해 사용자들이 눈치채지 못하도록 하는 기법
- ICMP 리다이렉트 (Redirect)
  - 3계층에서 스니핑 시스템을 네트워크에 존재하는 또 다른 라우터라고 알림으로써 패킷의 흐름을 바꾸는 공격
- 스위치의 SPAN/Port Mirroring 기능 이용

  - 스위치의 SPAN/Port Mirroring 기능은 스위치를 통과하는 모든 트래픽을 볼 수 있는 기능으로 특정 포트에 분석 장비를 접속하고 다른 포트의 트래픽을 분석 장비로 자동 복사해주는 기술
  - 관리적인 목적으로 사용하지만 공격자가 물리적으로 해당 포트에 접근할 수 있다면 손쉽게 패킷을 스니핑 할 수 있다.

###### 스니핑 탐지

- 스니퍼에 대한 탐지는 기본적으로 스니퍼가 Promiscuous 모드에서 작동한다는 데서 시작한다. promiscuous 모드란 유입 패킷에 대한 IP주소와 MAC 주소 필터링을 하지 않는다는 의미다.
- ping을 이용하는 방법: 대부분 스니퍼는 일반 TCP/IP에서 동작하기 때문에 Request를 받으면 Response를 전달한다. 이를 이용한 방법은 의심이 드는 호스트에 ping을 보낼때, 네트워크에 존재하지 않는 MAC 주소를 위장하여 보내는 것이다. 만약 ICMP Echo Reply를 받으면 해다 호스트가 스니핑을 하고 있는 것이다. 왜냐하면 존재하지 않는 MAC 주소를 사용했으므로 스니핑을 하지 않는 호스트는 누구도 ping Request를 볼 수 없는 것이 정상이기 때문이다.
- ARP를 이용하는 방법: ping과 유사한 방법으로 위조된 ARP Reqeust를 보냈을 때 ARP Response가 오면 Promiscuous 모드로 설정되어 있는 것이다.
- DNS 방법: 일반적으로 스니핑 프로그램은 사용자의 편의를 위해 스니핑한 시스템의 IP주소로 Inverse-DNS lookup을 수행한다. 이는 원격과 로컬에서 모두 사용할 수 있는 방법으로, 원격에서 테스트 대상 네트워크로 Ping sweep을 보내고, 들어오는 Inverse-DNS lookup을 감시하여 스니퍼를 탐지할 수 있다.
- 유인(Decoy) 방법: 스니핑 공격을 하는 공격자의 주요 목적은 계정과 패스워드의 획득에 있다. 보안 관리자는 이 점을 이용해 가짜 계정과 패스워드를 네트워크에 계속 뿌린다. 공격자는 이 계정과 패스워드를 이용해 접속을 시도하고, 이 접속을 시도하는 시스템을 탐지함으로써 스니퍼를 탐지할 수 있다.
- ARP watch: 초기에 MAC 주소와 IP주소의 매칭 값을 저장하고 ARP 트래픽을 모니터링하여 이를 변하게 하는 패킷이 탐지되면 관리자에게 메일로 알려주는 툴이다. 대부분의 공격 기법이 위조된 ARP를 사용하기 때문에 이를 쉽게 탐지할 수 있다.

###### 암호화

- 스니핑에 대한 대응책, 암호화 방법은 이용하는 서비스에 따라 다르다. 인터넷을 사용할 때, 이메일을 사용할 때의 암호화 방법 등 매두 다양하다.
- SSL: 암호화된 웹 서핑을 가능하게 해주며, 40비트와 128비트 두 가지 암호화 키 사용
- PGP, PEM, S/MIME: 이메일을 전송할 때 사용하는 암호화
- SSH: 텔넷과 같은 서비스의 암호화
- VPN: 공용 회선을 이용한 사설 암호화명

###### 네트워크 스니퍼(sniffer)

- 패킷 또는 LAN 세그먼트상을 지나는 트래픽을 분석할 수 있는 프로그램 혹은 장비를 가리키는 용어
- 스니퍼는 Promiscuous 모드로 동작하는 네트워크 어댑터를 이용하여 네트워크에 접속해야 하며, 이 어댑터의 드라이버는 데이터를 캡처한다.
- 패킷 스니핑 공격은 트래픽 통계 정보를 수집하는 패킷 분석기(Wireshark 등) 및 스니핑 공격을 위해 특별히 제작된 도구(Dniff 등)를 사용한다.

##### (5) 스푸핑(Spoofing)

- 스푸핑 공격은 공격자가 자신을 공격 대상자에게 노출시키지 않고 제 3의 사용자인 것처럼 MAC 주소, IP주소 등을 속이는 작업
- 스푸핑 공격은 주로 중간자 공격(Man In The Middle) 또는 DoS 공격 등에 사용된다.

###### ARP 스푸핑

> 공격 원리

- ARP는 호스트의 IP 주소를 MAC 주소로 변경하는 프로토콜이다. ARP 스푸핑은 호스트의 주소 매칭 테이블에 위조된 MAC 주소가 설정되도록 하는 공격
- ARP 스푸핑 공격은 사용자 시스템이 ARP Reply 메시지를 수신할 때마다 자신의 ARP Request 메시지 송신 여부와 관계없이 그리고 ARP Reply 메시지의 송신자에 대한 인증과정 없이 자신의 ARP 테이블을 갱신하는 ARP 프로토콜의 취약점을 이용한다
- 공격자는 주기적으로 ARP 스푸핑 공격을 수행하여 ARP 캐시 테이블의 공격 정보를 계속 유지한다. 이와 같이 ARP 캐시 테이블의 내용을 몰래 변경하는 작업을 ARP 캐시 포이즈닝(ARP Cache Poisoning)이라 한다.

> 보안 대책

- 가장 기본적인 대응은 동일 네트워크 내의 시스템들에 대한 ARP 캐시 테이블은 ARP Reply 메시지와 관계없이 관리자가 직접 정적(static)으로 작성함으로써 ARP 스푸핑 공격이 성립하지 않게 만드는 것.

###### IP 스푸핑

> 공격 원리

- 공격자가 자신의 IP주소가 아닌 신뢰관계(trust relationship)를 가진 시스템의 주소로 위장하여 공격대상 서버로부터 정보를 가로채는 방식이다.
- 신뢰관계에 있는 IP로 위장한 후 rlogin 등을 이용하여 공격대상 서버에 접속한다. 백도어 등을 설치하여 차후 공격 경로를 확보한다.

> 보안대책

- 외부에서 들어오는 패킷 중에서 출발지 IP 주소에 내부망 IP 주소를 가지고 있는 패킷을 라우터 등에서 패킷 필터링을 사용하여 막아낼 수 있다.
- 신뢰(트러스트)관계를 이용한 IP 스푸핑에 가장 좋은 대책은 트러스트를 사용하지 않는 것이다. 그러나 부득이하게 트러스트를 사용할 경우에는 트러스트된 시스템의 MAC 주소를 static으로 지정해야한다.
- IP 스푸핑 공격은 기본적으로 IP 프로토콜이 출발지 IP주소에 대한 인증 작업을 수행하지 않는데서 기인한다. 따라서 IP 주소 인증 기능이 보안된 프로토콜(IPSec)을 사용하는 것이 근본적인 대응책이 된다.
- TCP와 같은 상위 프로토콜에서 비정상적인 IP주소 시스템 간 통신을 방지하는 기능을 추가하는 것도 IP 스푸핑 공격의 중요한 대응책이 된다.

###### DNS 스푸핑

> 공격 원리

- 실제 DNS 서버보다 빨리 대상에게 DNS Response 패킷을 보내, 공격 대상이 잘못된 IP주소로 웹접속을 하도록 유도하는 공격
- DNS 스푸핑 공격이 ARP 스푸핑 공격보다 공격 응용 범위가 넓다. 즉, DNS 스푸핑 공격을 통해 공격 대상자를 어떤 사이트로 몰래 유인하여 파밍, 중간자 공격 등 2차 공격을 가할 수 있다.
- DNS 패킷은 UDP 패킷이므로 세션이 존재하지 않는다. 또한 먼저 도착한 패킷을 신뢰하며, 다음에 도착한 정보는 버린다. DNS 스푸핑은 DNS 서비스의 이런 특징을 이용한다.

> 보안대책

- 도메인 이름을 브라우저에 입력했을 때 무조건 DNS Query를 생성하는 것은 아니다. 사이트에 접속하면 MAC처럼 캐시에 도메인 이름에 대한 IP주소가 저장되었다가 다시 접속했을 때 DNS Query를 보내지 않고 캐시에서 읽어드린다.
- 그런 다음 hosts 파일을 통해 도메인 이름에 대한 IP 주소를 해석한다. 따라서 hosts 파일에 중요한 사이트의 IP 주소를 확인해 적어두면, 적어도 이 파일에 있는 사이트에 대해서는 DNS 스푸핑 공격을 당하지 않는다.

###### 이메일 스푸핑

- 공격자의 신분을 위장하여 이메일을 발송하는 공격으로 사회공학 기벙에 속한다.
- 악성코드를 메일에 첨부하여 발송하는 방식(MassMailer)으로 대표적인 사례로는 베이글 윔(Bagle Worm)이 있다.
- 대응책은 L7의 콘텍스트(context)필터링, 안티바이러스, 전자서명, 메일 발송 시 인증하는 방법이 있다.

##### (6) 세션 하이재킹(Session Hijacking)

- 공격자가 인증 작업 등이 완료되어 정상적으로 통신이 이루어지고 있는 다른 사용자(공격 대상자)의 세션을 가로채서 별도의 인증 작업 없이 가로챈 세션으로 통신을 계속하는 행위
- 세션 하이재킹은 인증 작업이 완료된 세션을 공격하므로 패스워드 스니핑과 재연공격(Replay Attack)등을 방지하기 위해 도입된 일회용 패스워드(One Time Password), 챌린지/응답(Challenge/Response) 기법 등을 사용하는 사용자 인증을 무력화시키는 매우 위험한 공격

###### TCP 연결 하이재킹(TCP Connection Hijacking)

- 다른 사용자의 TCP 연결을 가로채는 TCP 연결 하이재킹은 순서번호 추론(Sequence Number Prediction) 기반의 하이재킹과 스니핑 기반의 하이재킹으로 구분된다.
- TCP 세션 하이재킹이 스니핑과 다른 점은 명령의 실행이 가능하다는 것이다. 클라이언트와 똑같은 인터페이스가 제공된다. 따라서 TCP 세션 하이재킹을 적극적(active)공격 이라고 한다.

###### HTTP 세션 하이재킹(Session ID 하이재킹)

- 공격자가 특정 사용자의 유효기간이 남아있는 세션 식별자(Session ID)를 가로챌 수 있다면 별도의 인증 없이 해당 사용자의 권한으로 서버를 접근하는 세션 하이재킹 공격이 가능해진다.
- 대응책: 네트워크 트래픽 스니핑 방지 대책인 데이터 트래픽 암호화와 스니핑 도구 탐지 및 제거, 세션 식별자 추측과 전사 공격 대책으로 추측하기 어렵고 긴 세션 식별자를 사용한다.

### SECTION 27 IDS/IPS

#### 1. 침입탐지시스템(IDS)

#### 2. 침입방지시스템(IPS)

### SECTION 28 침입차단시스템(Firewall)

#### 1. 침입차단 시스템(방화벽, Firewall) 개요

#### 2. 침입차단시스템의 유형 분류

#### 3. 침입차단 시스템의 종류(구축 형태)

#### 4. iptables

### SECTION 29 VPN

#### 1. VPN(Virtual Private Network)

#### 2. IPSec(IP Security Protocol)

### SECTION 30 최신 네트워크 보안기술

#### 1. 최신 네트워크 보안기술

##### (1) 역추적 시스템

##### (2) ESM(Enterprise Security Management)

##### (3) NAC(Network Access Control)

##### (4) SIEM(Security Information Event Management)

##### (5) 패치관리시스템(PMS, Patch Management System)

## PART 06 애플리케이션 보안

### SECTION 31 FTP 보안

#### 1. 파일 관련 프로토콜

##### (1) FTP(File Transfer Protocol)

- 하나의 호스트에서 다른 호스트로 파일을 복사하기 위해 TCP/IP에 의해 제공되는 표준 기능
- FTP는 호스트 간에 두 개의 연결을 설정한다는 점에서 다른 클라이언트 서버 응용들과 다르다. 하나의 연결은 데이터 전송을 위해 사용되고, 또 다른 하나는 명령과 응답 등의 제어 장보를 위하여 사용한다.
- FTP는 두 개의 잘 알려진(well-known) TCP 포트를 사용한다. 포트 21번은 제어 연결을 위해 사용되고, 포트 20번은 데이터 연결을 위해 사용된다.

##### FTP 연결

- FTP 능동(Active) Mode (일반 연결)
  - 일반적으로 능동모드가 FTP 클라이언트의 기본값으로 설정된다. 클라이언트에서 서버측 21번 포트로 접속하여 제어채널을 생성하고 데이터는 서버에서 클라이언트로 접속하여 데이터를 보내는 방식이다.
  - 만약 클라이언트 PC에 방화벽이 설치되어 외부에서의 접속을 허용하지 않는다면 FTP 접속은 되지만 (제어채널은 연결되지만) 이후 데이터 채널 연결이 불가능하여 파일을 받을 수 없는 문제가 발생할 수 있다.
- FTP 수동(Passive) 모드 (수동 연결)
  - 클라이언트에서 서버측 21번 포트로 접속하여 제어채널을 생성하고 데이터 채널도 클라이언트에서 서버로 접속하여 데이터를 보내는 방식이다.

##### (2) 익명 FTP

- 많은 FTP 서버는 익명 FTP를 지원하여 서버에 계정이 없는 사용자가 서버 자원에 한정된 접근을 할 수 있는 권한을 제공한다. 익명 FTP는 기술지원이나 고객지원, 파일 배포 등을 하고자 하는 단체에서 사용하는 경우가 많다.
- 익명 FTP에 액세스하기 위해 사용자는 계정이나 패스워드가 필요하지 않다. 대신 사용자 이름으로 'anonymous'라는 단어를, 패스워드로 '이메일 주소'를 사용할 수 있다.
- 이 때 입력하는 비밀번호는 실제 비밀번호가 아니며 누가 접속하고 있는지 서버가 로그에 기록하는 데 쓰일 뿐이다.

##### (3) TFTP(Trivial File Transfer Protocol)

- FTP보다 더 간단한 TFTP
- UDP(69번 포트)를 사용한다.

##### (4) NFS와 삼바

###### NFS (Network File System)

- TCP/IP 프로토콜을 사용하여 네트워크상에서 파일시스템을 운영할 수 있도록 해주는 프로토콜
- 데이터의 보안과 무결성을 보장하면서 인증된 네트워크 사용자가 공유된 네트워크 파일을 마치 자신의 저장 장치에 있는 것처럼 사용할 수 있는 방법을 제공

###### 삼바 (Samba)

- SMB(Server Message Block) 프로토콜을 사용하여 유닉스 계열 시스템과 윈도우 시스템 간에 파일 및 프린터 자원을 공유할 수 있는 기능을 제공

#### 2. FTP 보안 위협 및 대책

##### FTP 보안

- FTP 프로토콜은 보안이 큰 문제가 되기 전에 설계되었다. 비록 FTP가 비밀번호를 요구하지만, 이 비밀번호는 평문으로 되어 있어, 공격자가 가로채어 사용할 수 있다.
- 데이터 전송 연결 또한 보호되지 않은 평문으로 데이터를 전송한다. 보안을 위해서는 FTP 응용 계층과 TCP 계층 사이에 보안 소켓 계층을 추가할 수 있다. 이러한 경우의 FTP를 SSL-FTP라 부른다.

##### SFTP(Secure File Transfer Protocol)

- 보안 채널을 사용해 자료를 전송하는 다른 방법은 SFTP(보안 파일 전송 프로토콜)라 불리는 다른 독립된 프로토콜을 사용하는 것이다. 이는 사실 SSH 프로토콜의 일부분인 SFTP라 불리는 Unix 프로그램이다.
- SSH에서 SSH 클라이언트와 SSH 서버 사이에 보안 연결이 성립되었을 때, 이 연결(다중 방식)을 사용 할 수 있는 응용 프로그램 중 하나가 SFTP다.
- 다시 말하면, SFTP는 SSH 응용 요소의 일부이다. SFTP 프로그램은 FTP처럼 동작할 수 있는 쌍방향 프로그램이며 SSH 클라이언트와 SSH 서버 사이에서 파일을 전송하기 위해 인터페이스 명령 세트를 사용한다.

##### TFTP 보안

- TFTP에 대한 중요한 점 하나는 보안에 대한 고려가 없다는 점이다. 심지어 사용자 확인이나 비밀번호도 없다. 그러므로 오늘날 해커로부터 파일을 보호하기 위한 예방조치가 취해져야 한다.
- 이를 수행하는 방법 중 하나는 TFTP가 중요하지 않은 파일에만 접근할 수 있도록 제한하는 것이다. 최소한의 보안성을 얻기 위한 한 가지 방법은 TFTP 서버 근처에 있는 라우터에 보안을 구현하여, 특정한 호스트만 서버에 접근 할 수 있도록 하는 것이다.
- TFTP가 필요한 경우 secure mode로 운영한다. secure mode는 chroot 기능을 이용하는 것으로 지정한 디렉터리를 최상위 디렉터리로 지정하여 지정한 디렉터리의 상위 디렉터리로 접근하지 못하도록 제한하는 방식이다.

##### Bounce attack

- 제어 채널과 데이터 채널을 다르게 사용하고 데이터 채널을 생성할 때 목적지를 확인하지 않는 FTP 설계의 구조적 취약점을 이용하는 공격
- 능동 모드에서 FTP 서버의 파일을 요청하면 클라이언트에서 파일을 받을 IP와 포트를 지정해서 전달해준다. (PORT 명령) 이때 IP와 포트를 요청한 클라이언트가 아닌 임의의 주소로 지정할 수 있는데 이런한 FTP 설계의 취약점을 이용하는 방식이다.
- 주로 익명 FTP 서버를 이용, PORT 명령을 조작하여 공격대상 네트워크를 스캔하고 FTP 서버로 하여금 공격자가 원하는 곳으로 데이터를 전송하게 한다.

##### Anonymous FTP 취약점

- 보안 절차를 거치지 않는 익명의 사용자에게 FTP 서버로의 접근을 허용한다.
- 익명 사용자가 서버에 쓰기 권한이 있을 때 악성 코드 생성이 가능하다.
- Anonymous FTP 보안 대책
  - Anonymous FTP는 보안상 심각한 취약점을 가지고 있기 때문에 반드시 사용해야하는 경우가 아니라면 서비스를 제거한다.

##### FTP 접근 제어 설정

- ftpusers 파일을 통한 접근 제어
  - FTP 서비스는 기본적으로 평문 송수신을 하기 때문에 아이디 및 패스워드가 노출되기 쉽다. 따라서 중요 계정(root 등)에 대해서는 FTP 직접 접속을 제한해야한다.
  - ftpusers 파일은 접속을 제한할 계정정보를 담고 있는 설정 파일이다. 따라서 root 등 중요 계정을 ftpusers 파일에 명시하여 접속을 제한한다.
- TCPWrapper를 통한 접근 제어
  - TCPWrapper의 설정파일인 hosts.allow, hosts.deny 파일을 이용하여 IP 기반의 접근제어를 수행
  - FTP 데몬 프로그램별로 TCPWrapper 연동 설정이 필요

#### 3. FTP 서비스 운영

### SECTION 32 이메일 보안

#### 1. 이메일 관련 프로토콜

#### 2. 이메일 콘텐츠 보안을 위한 보안 기술

#### 3. 스팸 메일 보안 대응 기술

#### 4. sendmail

### SECTION 33 웹 보안(Web Security)

#### 1. 웹 보안 개요

#### 2. 월드와이드웹과 HTTP

#### 3. SSL/TLS

#### 4. 웹서버 보안

##### (1) IIS 보안설정

##### (2) Apache 보안설정

#### 5. 웹(Web) 보안위협 및 대응책

##### (2) 주요 웹 보안위협 및 대응책

- SQL Injection
- 사이트 간 스크립팅 (CSS[XSS] Cross Site Scripting)
- 사이트 간 요청 위조 (CSRF[XSRF], Cross Site Request Forgery)
- 직접 객체 참조
- 보안 설정 취약점

##### (3) 웹의 취약점 보완

- 특수문자 필터링
- 서버측 통제 적용
- 지속적인 세션 관리
- 웹 방화벽(WAF, Web Application Firewall)

#### 6. 소프트웨어 개발 보안

### SECTION 34 DHCP와 DNS 보안

#### 1. 호스트 설정과 호스트 설정 프로토콜

#### 2. DNS(Domain Name System)

##### (4) DNS 룩업(Loopup) 유틸리티

- nslookup 유틸리티
- dis(Domain Infomation Groper) 유틸리티
- host 유틸리티
- whois 명령어

#### 3. DNS 보안

##### (2) DNS 스푸핑(DNS Spoofing)

- 스니핑 (Sniffing) 기반의 DNS Spoofing 공격
- DNS Cache Poisoning 공격

#### 4. DNS 서버 보안 설정

### SECTION 35 데이터베이스 보안

#### 1. 데이터베이스 기본 개념

#### 2. 데이터베이스 보안 요구사항

#### 3. 데이터베이스 보안 통제

#### 4. DBMS 보안 관리

### SECTION 36 전자상거래 보안

#### 1. 전자상거래 개요

#### 2. 전자상거래의 정보 보호

#### 3. SET(Secure Electronic Transaction)

- 신용카드 회사인 비자와 마스터카드가 합동하여 개발하였으며, 인터넷상에서 신용카드를 이용한 상품구매시 안전한 대금결제과정 처리를 위해 RSA 암호화와 인증기술을 이용한다.
- 네트워크상에서 민감한 개인금융정보를 안전하게 전송하기 위해 개발된 프로토콜인데 현재까지 가장 안전한 전자결제방안으로 평가되고 있다.
- SET은 가장 중요한 두 가지 기술을 사용한다. 바로 전자봉투와 이중 서명이다.
- SET 참여 주체
  - 카드 소지자(Cardholder)
  - 발행사(Issuer)
  - 가맹정(Merchant)
  - 지불 은행(매입사, Acquirer)
  - 지불 게이트웨이(Payment Gateway)
  - 인증 기관(CA, Certification Authority)
- 장단점
  - 장점
    - 전자거래의 사기를 방지
    - 기존의 신용카드 기반을 그대로 활용
    - 신용카드 번호가 상점에게 알려지지 않고 지불 게이트웨이에게 알려짐
    - SSL의 단점 (상인에게 지불정보 노출)을 해결
    - 상점에 의한 사기 가능성 감소
    - 서명 기능이 있어 부인방지 서비스 제공
  - 단점
    - 암호 프로토콜이 너무 복잡함
    - RSA 동작은 프로토콜의 속도를 크게 저하시킴. 속도가 느림.
    - 카드 소지자에게 전자지갑 소프트웨어를 요구
    - 상점에 소프트웨어를 요구
    - 지불 게이트웨이에 거래를 전자적으로 처리하기 위한 별도의 하드웨어와 소프트웨어를 요구

#### 4. 전자상거래 응용 보안

### SECTION 37 침해사고 대응(디지털 포렌식)

#### 1. 해킹

#### 2. 침해사고 대응과 포렌식

##### (1) 컴퓨터 침해 대응팀

- CERT(Computer Emergency Response Team)

##### (2) 디지털 포렌식(Digital Forensics)

##### (3) 증거(Evidence)

##### (4) 디지털 증거 복구

##### (5) 데이터 복구 기법 피하기(Data Sanitization)

### SECTION 38 각종 애플리케이션 보안위협 및 대응책

#### 1. 각종 애플리케이션 보안위협 및 대응책

- 좀비와 봇(Bot)
- 살라미 공격
- 데이터 디들링(Data Diddling)
- 이블 트윈 공격(Evil Twin Attack)

#### 2. 자바 보안

- 클래스 로더(Class Loader)
- 바이트코드 검사기(Verifier = Interpreter)
- 보안관리자(Security manager)

## PART 07 정보보안 관리 및 법규

### SECTION 39 정보보호 거버넌스와 관리 체계 수립

#### 1. 정보보호 거버넌스

#### 2. IT 보안 관리

#### 3. 정보보호 정책, 절차, 표준, 지침, 기준선

#### 4. 인적 자원 보안

### SECTION 40 정보보호 위험 관리

#### 1. 위험관리

#### 2. 위험분석(Risk Analysis)

### SECTION 41 BCP/DRP

#### 1. BCP/DRP

### SECTION 42 정보보호 인증제도

#### 1. 보안 제품 평가방법 및 기준

#### 2. 정보보호관리체계 인증

#### 3. 정보보호 및 개인정보보호 관리체계(ISMS-P 인증)

#### 4. 기타 인증제도 및 정보보호 활동

### SECTION 43 정보보호 관련 법규 Ⅰ

#### 1. 개인정보보호법(2017.10.19.)

#### 2. 정보통신망 이용촉진 및 정보보호 등에 관한 법률(2019.6.25)

#### 3. 위치정보의 보호 및 이용 등에 관한 법률(2019.6.25)

#### 4. 신용정보의 이용 및 보호에 관한 법률(2018.12.31)

### SECTION 44 정보보호 관련 법규 Ⅱ

#### 1. 정보통신기반 보호법(2018.5.22.)

#### 2. 클라우드컴퓨팅 발전 및 이용자 보호에 관한 법률(2017.7.26.)

#### 3. 전자정부법(2017.10.2### 4.)
